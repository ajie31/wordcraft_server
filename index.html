<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>WordCraft</title>
    <link rel="stylesheet" href="styles.css?v=1.0.2" />
    <!-- IntroJS CSS -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/intro.js@7.2.0/minified/introjs.min.css"
    />
    <!-- here is new style -->
    <link rel="stylesheet" href="additional_styles.css" />

    <link
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined"
      rel="stylesheet"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap"
      rel="stylesheet"
    />
    <script
      defer
      data-domain="wordcraft-d6102.web.app"
      src="https://plausible.io/js/script.js"
    ></script>
  </head>
  <body>
    <button
      id="overlayMenu"
      class="overlay-menu"
      onclick="toggleMenu()"
      style="display: none"
    ></button>
    <div id="mobileNavMenu" class="mobile-nav-menu" style="display: none">
      <div class="anchor-arrow">
        <svg
          width="26"
          height="11"
          viewBox="0 0 26 11"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path d="M13 0L25.9904 10.5H0.00961876L13 0Z" fill="white" />
        </svg>
      </div>
      <div class="nav-menu" id="navMenu">
        <div id="mobileInteractionToggleL" class="mobile-interaction-toggle">
          <span class="input-mode-label">Input mode</span>
          <div class="interaction-btn-wrap">
            <button id="dragModeBtnL" class="interaction-btn">
              Drag and Drop
            </button>
            <button id="tapModeBtnL" class="interaction-btn active">
              Tap Mode
            </button>
          </div>
        </div>
        <div class="nav-menu-rules">
          <span class="input-mode-label">How to Play</span>
          <button
            class="btn"
            id="rulesBtnL"
            data-intro="After submitting, you'll see your final score and can enter your name for the daily leaderboard. Each day brings a new challenge with the same tiles for everyone, so you can compare your skill with others. Have fun!"
            data-step="7"
          >
            <svg
              width="20"
              height="16"
              viewBox="0 0 20 16"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M10 8L2.54 5.02L3 16H1L1.48 4.59L0 4L10 0L20 4L10 8ZM10 3C9.45 3 9 3.22 9 3.5C9 3.78 9.45 4 10 4C10.55 4 11 3.78 11 3.5C11 3.22 10.55 3 10 3ZM10 9L15.57 6.77C16.28 7.71 16.77 8.84 16.93 10.07C16.63 10.03 16.32 10 16 10C13.45 10 11.22 11.37 10 13.41C9.38045 12.371 8.50187 11.5106 7.45018 10.9129C6.39849 10.3152 5.20968 10.0006 4 10C3.68 10 3.37 10.03 3.07 10.07C3.23 8.84 3.72 7.71 4.43 6.77L10 9Z"
                fill="white"
              />
            </svg>

            Show Tutorial
          </button>
        </div>
      </div>
    </div>
    <div id="toast" class="toast"></div>
    <div id="achievementToast" class="achievement-toast"></div>

    <div
      class="game-container"
      data-intro="Welcome to WordCraft! This word-building game gives you a daily challenge to create words on a game board, similar to Scrabble. You'll receive a set of letter tiles and need to arrange them strategically to score points."
      data-step="1"
    >
      <div class="game-header">
        <div class="logo-score-group">
          <div class="display-logo">
            <img src="src/icons/wordcraft_logo.svg" alt="wordcraft_logo" />
          </div>
          <div class="score-display">
            <span class="score-text">Score</span
            ><span class="score-value">0</span>
          </div>
        </div>

        <div class="header-button-group">
          <div id="mobileInteractionToggle" class="mobile-interaction-toggle">
            <span class="input-mode-label">Input mode</span>
            <div class="interaction-btn-wrap">
              <button id="dragModeBtn" class="interaction-btn">
                Drag and Drop
              </button>
              <button id="tapModeBtn" class="interaction-btn active">
                Tap Mode
              </button>
            </div>
          </div>
          <button
            class="btn"
            id="rulesBtn"
            data-intro="After submitting, you'll see your final score and can enter your name for the daily leaderboard. Each day brings a new challenge with the same tiles for everyone, so you can compare your skill with others. Have fun!"
            data-step="7"
          >
            <svg
              width="20"
              height="16"
              viewBox="0 0 20 16"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M10 8L2.54 5.02L3 16H1L1.48 4.59L0 4L10 0L20 4L10 8ZM10 3C9.45 3 9 3.22 9 3.5C9 3.78 9.45 4 10 4C10.55 4 11 3.78 11 3.5C11 3.22 10.55 3 10 3ZM10 9L15.57 6.77C16.28 7.71 16.77 8.84 16.93 10.07C16.63 10.03 16.32 10 16 10C13.45 10 11.22 11.37 10 13.41C9.38045 12.371 8.50187 11.5106 7.45018 10.9129C6.39849 10.3152 5.20968 10.0006 4 10C3.68 10 3.37 10.03 3.07 10.07C3.23 8.84 3.72 7.71 4.43 6.77L10 9Z"
                fill="white"
              />
            </svg>

            How to Play
          </button>
          <div class="btn-maximize-display">
            <button>
              <span class="material-symbols-outlined">crop_free</span>
            </button>
          </div>
          <div class="btn-menu">
            <button onclick="toggleMenu()">
              <span class="material-symbols-outlined">menu</span>
            </button>
          </div>
        </div>
      </div>

      <div class="main-content">
        <div class="game-area">
          <div class="board-container">
            <div
              class="game-board"
              id="gameBoard"
              data-intro="The game board is where you'll place your tiles. To maximize points, use special squares: DL (Double Letter), TL (Triple Letter), DW (Double Word), and TW (Triple Word). Important: The center star square must have a tile placed on it before you can submit your score."
              data-step="3"
            >
              <!-- Board cells will be generated by JavaScript -->
            </div>
            <div
              class="game-board-imagine"
              id="gameBoard-imagine"
              data-step="3"
            >
              <!-- Board cells will be generated by JavaScript -->
            </div>
          </div>

          <div class="tile-area">
            <div id="validationErrors" class="validation-errors"></div>

            <!-- Mobile Interaction Mode Toggle -->

            <div class="game-controls-mobile">
              <button
                class="btn btn-primary"
                id="submitBtn"
                data-intro="Once you've arranged your tiles, tap 'Submit Words' to score them. Invalid words will be highlighted in red. Your goal is to score as many points as possible with the available tiles. Try to use all your tiles for maximum points!"
                data-step="6"
              >
                Submit Words
                <svg
                  width="17"
                  height="18"
                  viewBox="0 0 17 18"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    d="M16.235 7.70999L2.66001 0.404991C1.52001 -0.210009 0.20001 0.854991 0.56001 2.09999L2.42001 8.60999C2.49501 8.87999 2.49501 9.14999 2.42001 9.41999L0.56001 15.93C0.20001 17.175 1.52001 18.24 2.66001 17.625L16.235 10.32C16.4666 10.1935 16.6599 10.0069 16.7945 9.77992C16.9291 9.55294 17.0002 9.2939 17.0002 9.02999C17.0002 8.76608 16.9291 8.50704 16.7945 8.28006C16.6599 8.05308 16.4666 7.86653 16.235 7.73999V7.70999Z"
                    fill="white"
                  />
                </svg>
              </button>
              <button
                class="btn"
                id="clearBtn"
                data-intro="Form valid dictionary words by placing tiles adjacent to each other, reading left-to-right or top-to-bottom. All tiles must connect to each other - no isolated groups allowed. Words must be at least two letters long."
                data-step="4"
              >
                <svg
                  width="18"
                  height="22"
                  viewBox="0 0 18 22"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    fill-rule="evenodd"
                    clip-rule="evenodd"
                    d="M11.28 5.80189e-08C11.6998 0.00010886 12.1088 0.132286 12.4493 0.377808C12.7898 0.62333 13.0444 0.96975 13.177 1.368L13.72 3H17C17.2652 3 17.5196 3.10536 17.7071 3.29289C17.8946 3.48043 18 3.73478 18 4C18 4.26522 17.8946 4.51957 17.7071 4.70711C17.5196 4.89464 17.2652 5 17 5L16.997 5.071L16.13 17.214C16.0759 17.9706 15.7372 18.6786 15.182 19.1956C14.6269 19.7125 13.8965 19.9999 13.138 20H4.862C4.10346 19.9999 3.37311 19.7125 2.81797 19.1956C2.26283 18.6786 1.92411 17.9706 1.87 17.214L1.003 5.07L1 5C0.734784 5 0.48043 4.89464 0.292893 4.70711C0.105357 4.51957 0 4.26522 0 4C0 3.73478 0.105357 3.48043 0.292893 3.29289C0.48043 3.10536 0.734784 3 1 3H4.28L4.823 1.368C4.9557 0.969588 5.21043 0.623052 5.5511 0.377515C5.89176 0.131978 6.30107 -0.000101061 6.721 5.80189e-08H11.28ZM6 8C5.75507 8.00003 5.51866 8.08996 5.33563 8.25272C5.15259 8.41547 5.03566 8.63975 5.007 8.883L5 9V15C5.00028 15.2549 5.09788 15.5 5.27285 15.6854C5.44782 15.8707 5.68695 15.9822 5.94139 15.9972C6.19584 16.0121 6.44638 15.9293 6.64183 15.7657C6.83729 15.6021 6.9629 15.3701 6.993 15.117L7 15V9C7 8.73478 6.89464 8.48043 6.70711 8.29289C6.51957 8.10536 6.26522 8 6 8ZM12 8C11.7348 8 11.4804 8.10536 11.2929 8.29289C11.1054 8.48043 11 8.73478 11 9V15C11 15.2652 11.1054 15.5196 11.2929 15.7071C11.4804 15.8946 11.7348 16 12 16C12.2652 16 12.5196 15.8946 12.7071 15.7071C12.8946 15.5196 13 15.2652 13 15V9C13 8.73478 12.8946 8.48043 12.7071 8.29289C12.5196 8.10536 12.2652 8 12 8ZM11.28 2H6.72L6.387 3H11.613L11.28 2Z"
                    fill="#ECA449"
                  />
                </svg>
              </button>
              <button
                class="btn"
                id="shuffleBtn"
                data-intro="Look for special tiles in your rack! Wild cards (with a * symbol) can represent any letter - tap to select which letter you want. Some days, you might also get bonus tiles that double the score of the entire word they're part of."
                data-step="5"
              >
                <svg
                  width="16"
                  height="16"
                  viewBox="0 0 16 16"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    d="M10 16V14H12.6L9.425 10.825L10.85 9.4L14 12.55V10H16V16H10ZM1.4 16L0 14.6L12.6 2H10V0H16V6H14V3.4L1.4 16ZM5.175 6.575L0 1.4L1.4 0L6.575 5.175L5.175 6.575Z"
                    fill="#ECA449"
                  />
                </svg>
              </button>
            </div>
            <div class="page-letter-wrap">
              <div
                class="letter-rack"
                id="letterRack"
                data-intro="At the bottom of the screen, you'll find your letter tiles. Each letter has a point value (shown in the corner). To play, either drag a tile or tap to select it, then tap a board position to place it."
                data-step="2"
              >
                <!-- Tiles will be generated by JavaScript -->
              </div>
            </div>

            <div
              id="postGameMessage"
              class="post-game-message"
              style="display: none"
            >
              <p>
                Today's game completed! Next daily challenge available in
                <span id="postGameCountdown">23:59:59</span>
              </p>
              <button class="btn btn-primary" id="reopenLeaderboardBtn">
                Show Results
              </button>
            </div>
          </div>
        </div>

        <div class="game-controls">
          <button
            class="btn btn-primary"
            id="submitBtn"
            data-intro="Once you've arranged your tiles, tap 'Submit Words' to score them. Invalid words will be highlighted in red. Your goal is to score as many points as possible with the available tiles. Try to use all your tiles for maximum points!"
            data-step="6"
          >
            <svg
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
            Submit Words
          </button>
          <button
            class="btn"
            id="clearBtn"
            data-intro="Form valid dictionary words by placing tiles adjacent to each other, reading left-to-right or top-to-bottom. All tiles must connect to each other - no isolated groups allowed. Words must be at least two letters long."
            data-step="4"
          >
            <svg
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M3 6h18"></path>
              <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
              <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path>
            </svg>

            Clear Board
          </button>
          <button
            class="btn"
            id="shuffleBtn"
            data-intro="Look for special tiles in your rack! Wild cards (with a * symbol) can represent any letter - tap to select which letter you want. Some days, you might also get bonus tiles that double the score of the entire word they're part of."
            data-step="5"
          >
            <svg
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <polyline points="16 3 21 3 21 8"></polyline>
              <line x1="4" y1="20" x2="21" y2="3"></line>
              <polyline points="21 16 21 21 16 21"></polyline>
              <line x1="15" y1="15" x2="21" y2="21"></line>
              <line x1="4" y1="4" x2="9" y2="9"></line>
            </svg>
            Shuffle Tiles
          </button>
          <button
            class="btn"
            id="rulesBtn"
            data-intro="After submitting, you'll see your final score and can enter your name for the daily leaderboard. Each day brings a new challenge with the same tiles for everyone, so you can compare your skill with others. Have fun!"
            data-step="7"
          >
            <svg
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <circle cx="12" cy="12" r="10"></circle>
              <line x1="12" y1="16" x2="12" y2="12"></line>
              <line x1="12" y1="8" x2="12.01" y2="8"></line>
            </svg>
            How to Play
          </button>
        </div>
      </div>
      <div class="ads-wrap">
        <div class="ads-content">
          <h3>ads here</h3>
          <!-- add advertisement here -->
        </div>
      </div>
    </div>

    <!-- Modals -->
    <div class="modal" id="welcomeModal">
      <div class="modal-content">
        <h2 class="modal-title">Welcome to WordCraft!</h2>
        <p class="modal-text">
          Create words on the board using your daily letter tiles. Arrange them
          strategically to score the most points!
        </p>
        <ul class="rules-list">
          <li>
            Place tiles anywhere, but make sure to use the center star square
          </li>
          <li>Create connected words like in Scrabble</li>
          <li>Use special squares for bonus points</li>
          <li>Look for special tiles: Wild cards and bonus tiles!</li>
        </ul>
        <p>You can drag tiles or click to select and place them.</p>
        <div class="modal-buttons">
          <button class="btn btn-primary" id="startGameBtn">
            Start Playing
          </button>
        </div>
      </div>
    </div>

    <!-- Tutorial Modal -->
    <div class="tutorial-modal" id="tutorialModal">
      <div class="tutorial-content">
        <h2 class="tutorial-title">WordCraft Tutorial</h2>
        <div class="tutorial-steps">
          <!-- Step 1: Introduction -->
          <div class="tutorial-step" data-step="1">
            <div class="tutorial-text">
              Welcome to WordCraft! This word-building game gives you a daily
              challenge to create words on a game board, similar to Scrabble.
              You'll receive a set of letter tiles and need to arrange them
              strategically to score points.
            </div>
          </div>

          <!-- Step 2: Letter Tiles -->
          <div class="tutorial-step" data-step="2">
            <div class="tutorial-text">
              At the bottom of the screen, you'll find your letter tiles. Each
              letter has a point value (shown in the corner). To play, either
              drag a tile or tap to select it, then tap a board position to
              place it.
            </div>
          </div>

          <!-- Step 3: Game Board -->
          <div class="tutorial-step" data-step="3">
            <div class="tutorial-text">
              The game board is where you'll place your tiles. To maximize
              points, use special squares: DL (Double Letter), TL (Triple
              Letter), DW (Double Word), and TW (Triple Word). Important: The
              center star square must have a tile placed on it before you can
              submit your score.
            </div>
          </div>

          <!-- Step 4: Word Formation -->
          <div class="tutorial-step" data-step="4">
            <div class="tutorial-text">
              Form valid dictionary words by placing tiles adjacent to each
              other, reading left-to-right or top-to-bottom. All tiles must
              connect to each other - no isolated groups allowed. Words must be
              at least two letters long.
            </div>
          </div>

          <!-- Step 5: Special Tiles -->
          <div class="tutorial-step" data-step="5">
            <div class="tutorial-text">
              Look for special tiles in your rack! Wild cards (with a * symbol)
              can represent any letter - tap to select which letter you want.
              Some days, you might also get bonus tiles that double the score of
              the entire word they're part of.
            </div>
          </div>

          <!-- Step 6: Submitting Words -->
          <div class="tutorial-step" data-step="6">
            <div class="tutorial-text">
              Once you've arranged your tiles, tap "Submit Words" to score them.
              Invalid words will be highlighted in red. Your goal is to score as
              many points as possible with the available tiles. Try to use all
              your tiles for maximum points!
            </div>
          </div>

          <!-- Step 7: Leaderboard -->
          <div class="tutorial-step" data-step="7">
            <div class="tutorial-text">
              After submitting, you'll see your final score and can enter your
              name for the daily leaderboard. Each day brings a new challenge
              with the same tiles for everyone, so you can compare your skill
              with others. Have fun!
            </div>
          </div>
        </div>

        <div class="tutorial-progress">
          <!-- Progress dots will be added by JavaScript -->
        </div>

        <div class="tutorial-controls">
          <button class="tutorial-btn tutorial-btn-back" id="tutorialBackBtn">
            Back
          </button>
          <button class="tutorial-btn tutorial-btn-skip" id="tutorialSkipBtn">
            Skip Tutorial
          </button>
          <button class="tutorial-btn tutorial-btn-next" id="tutorialNextBtn">
            Next
          </button>
        </div>
      </div>
    </div>

    <div class="modal" id="rulesModal">
      <div class="modal-content">
        <h2 class="modal-title">How to Play</h2>
        <p class="modal-text">WordCraft is a daily word-building challenge.</p>
        <ul class="rules-list">
          <li>
            <strong>Placing Tiles:</strong> Drag or click letters to place them
            on the board
          </li>
          <li>
            <strong>Center Square:</strong> The center star square must have a
            tile before submitting
          </li>
          <li>
            <strong>Word Formation:</strong> Words can be read left-to-right or
            top-to-bottom
          </li>
          <li>
            <strong>Connecting Words:</strong> All tiles must be connected (no
            isolated words)
          </li>
          <li>
            <strong>Valid Words:</strong> Only valid dictionary words will count
            towards your score
          </li>
          <li>
            <strong>Special Squares:</strong>
            <ul>
              <li>DL - Double Letter Score</li>
              <li>TL - Triple Letter Score</li>
              <li>DW - Double Word Score</li>
              <li>TW - Triple Word Score</li>
            </ul>
          </li>
          <li>
            <strong>Special Tiles:</strong>
            <ul>
              <li>Wild Card - Can represent any letter</li>
              <li>Bonus Tile - Doubles the score of the entire word</li>
            </ul>
          </li>
          <li>
            <strong>Scoring:</strong> Points based on letter values and bonus
            squares
          </li>
          <li>
            <strong>Daily Challenge:</strong> Everyone gets the same letters
            each day
          </li>
        </ul>
        <div class="modal-buttons">
          <button class="btn" id="closeRulesBtn">Got It</button>
          <button class="btn btn-primary" id="showTutorialFromRulesBtn">
            Interactive Tutorial
          </button>
        </div>
      </div>
    </div>

    <div class="modal" id="confirmSubmitModal">
      <div class="modal-content">
        <h2 class="modal-title">Submit Your Words?</h2>
        <p class="modal-text">
          Are you sure you want to submit your words? This will end your game
          for today and record your score on the leaderboard.
        </p>
        <div class="modal-buttons">
          <button class="btn" id="cancelSubmitBtn">Cancel</button>
          <button class="btn btn-primary" id="confirmSubmitBtn">Submit</button>
        </div>
      </div>
    </div>

    <!-- New wildcard selection modal -->
    <div class="modal" id="wildcardModal">
      <div class="modal-content">
        <h2 class="modal-title">Select a Letter</h2>
        <p class="modal-text">
          Choose which letter this wildcard should represent:
        </p>
        <div class="letter-grid" id="wildcardLetterGrid">
          <!-- Will be filled dynamically -->
        </div>
        <button class="btn" id="cancelWildcardBtn">Cancel</button>
      </div>
    </div>

    <div class="modal" id="finishGameModal">
      <div class="modal-content">
        <h2 class="modal-title">Game Completed!</h2>
        <div class="finish-game-container">
          <p class="final-message">
            Your final score for today's WordCraft challenge:
          </p>
          <div class="final-score" id="finalScore">0</div>

          <!-- Nickname Input Form -->
          <div id="nicknameForm" class="nickname-form">
            <p>Enter a nickname to save your score:</p>
            <div class="nickname-input-container">
              <input
                type="text"
                id="nicknameInput"
                maxlength="15"
                placeholder="Your nickname"
                pattern="[A-Za-z0-9 _-]+"
                title="Letters, numbers, spaces, underscores and hyphens only"
              />
              <button id="saveScoreBtn" class="btn btn-primary">
                Save Score
              </button>
            </div>
            <p id="saveScoreMessage" class="save-score-message"></p>
          </div>

          <!-- Leaderboard Tabs -->
          <div class="leaderboard-tabs">
            <button class="tab-btn active" data-tab="daily">
              Today's Scores
            </button>
            <button class="tab-btn" data-tab="alltime">
              All-Time High Scores
            </button>
            <button class="tab-btn" data-tab="yesterdayBest">
              Yesterday's Best
            </button>
            <button
              class="refresh-btn"
              id="refreshLeaderboardBtn"
              title="Refresh Scores"
            >
              <svg
                width="16"
                height="16"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path d="M23 4v6h-6" />
                <path d="M1 20v-6h6" />
                <path
                  d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"
                />
              </svg>
            </button>
          </div>

          <!-- Leaderboard Container -->
          <div id="leaderboardContainer">
            <div class="leaderboard-loading" id="leaderboardLoading">
              Loading scores...
            </div>

            <!-- Standard Leaderboard Table (for daily and all-time) -->
            <table class="leaderboard" id="scoreLeaderboard">
              <thead>
                <tr>
                  <th>Rank</th>
                  <th>Player</th>
                  <th>Score</th>
                </tr>
              </thead>
              <tbody id="leaderboardBody">
                <!-- Leaderboard entries will be added here -->
              </tbody>
            </table>

            <!-- Yesterday's Best Board View (initially hidden) -->
            <div
              id="yesterdayBestContainer"
              class="yesterday-best-container"
              style="display: none"
            >
              <div class="yesterday-best-header">
                <div class="yesterday-best-info">
                  <div class="yesterday-best-player" id="yesterdayBestPlayer">
                    WordWizard
                  </div>
                  <div class="yesterday-best-score" id="yesterdayBestScore">
                    Score: 285
                  </div>
                </div>
                <div class="yesterday-best-controls">
                  <button id="toggleTilesBtn" class="btn btn-small">
                    Hide Tiles
                  </button>
                </div>
              </div>
              <div class="yesterday-best-board-container">
                <div class="yesterday-best-board" id="yesterdayBestBoard">
                  <!-- Board will be rendered here dynamically -->
                </div>
              </div>
              <div class="yesterday-best-message">
                <p>This is the highest scoring board from yesterday!</p>
              </div>
            </div>
          </div>

          <!-- Statistics Section -->
          <div class="stats-container">
            <h3 class="stats-title">Your Stats</h3>
            <div class="stats-grid" id="playerStats">
              <!-- Will be filled dynamically -->
            </div>
          </div>

          <!-- Achievements Section -->
          <div class="achievements-container">
            <h3 class="achievements-title">Achievements</h3>
            <div class="achievements-grid" id="playerAchievements">
              <!-- Will be filled dynamically -->
            </div>
          </div>

          <div class="share-container">
            <p class="share-score-text">Share your score with friends:</p>
            <button class="share-button" id="shareScoreBtn">
              <svg
                width="16"
                height="16"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path>
                <polyline points="16 6 12 2 8 6"></polyline>
                <line x1="12" y1="2" x2="12" y2="15"></line>
              </svg>
              Share Score
            </button>
          </div>

          <div class="countdown">
            <div class="countdown-label">Next daily challenge in</div>
            <div class="countdown-time" id="leaderboardCountdown">23:59:59</div>
          </div>

          <button class="btn btn-primary" id="closeLeaderboardBtn">
            Close
          </button>
        </div>
      </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <!-- IntroJS -->
    <script src="https://cdn.jsdelivr.net/npm/intro.js@7.2.0/minified/intro.min.js"></script>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.19.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.19.1/firebase-firestore-compat.js"></script>

    <script>
      // menu mobile controller

      function toggleMenu() {
        console.log("menu open");
        const navNemu = document.getElementById("mobileNavMenu");
        const overlay = document.getElementById("overlayMenu");
        if (overlay.style.display === "none") {
          overlay.style.display = "block"; // Hide the overlay
          navNemu.style.display = "flex";
        } else {
          overlay.style.display = "none"; // Show the overlay
          navNemu.style.display = "none";
        }
      }

      // Your web app's Firebase configuration
      const firebaseConfig = {
        apiKey: "AIzaSyCJHbFjv4QqkwdF9uutiCEJtU471lHZWKU",
        authDomain: "wordcraft-d6102.firebaseapp.com",
        projectId: "wordcraft-d6102",
        storageBucket: "wordcraft-d6102.firebasestorage.app",
        messagingSenderId: "972502803354",
        appId: "1:972502803354:web:ee8f30053b5a5f6a2d9023",
        measurementId: "G-HQF2RV9CDQ",
      };

      // Store pending scores that need to be synced to Firebase
      let pendingScores = [];

      // Load any pending scores from localStorage
      try {
        const savedPendingScores = localStorage.getItem(
          "wordcraftPendingScores"
        );
        if (savedPendingScores) {
          pendingScores = JSON.parse(savedPendingScores);
          console.log(`Loaded ${pendingScores.length} pending scores to sync`);
        }
      } catch (e) {
        console.error("Error loading pending scores:", e);
      }

      // Flag to track Firebase state
      let firebaseReady = false;
      let pendingFirebaseInit = false;
      let initRetryCount = 0;
      const MAX_INIT_RETRIES = 3;

      // Helper to normalize date strings
      function normalizeDateStr(dateObj) {
        if (!dateObj) return "";
        return dateObj.toISOString().split("T")[0]; // YYYY-MM-DD format
      }

      // Consistent timestamp handling
      function getNormalizedToday() {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        return today;
      }

      // Initialize Firebase with retry logic
      function initFirebase() {
        if (pendingFirebaseInit) return;

        try {
          pendingFirebaseInit = true;

          // Initialize Firebase
          if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
          }

          // Create a reference to the Firestore database
          const db = firebase.firestore();

          console.log("Trying to initialize Firebase with Firestore");

          // Enable offline persistence with better settings
          db.settings({
            cacheSizeBytes: firebase.firestore.CACHE_SIZE_UNLIMITED,
          });

          db.enablePersistence({ synchronizeTabs: true })
            .then(() => {
              console.log(
                "Firebase offline persistence enabled with multi-tab support"
              );
              firebaseReady = true;

              // Real Firebase implementation
              window.firebaseDB = {
                saveScore: async function (nickname, score) {
                  try {
                    const now = new Date();
                    const today = getNormalizedToday();

                    // Use deviceId to avoid duplication across devices
                    let deviceId = localStorage.getItem("wordcraftDeviceId");
                    if (!deviceId) {
                      deviceId =
                        "device_" + Math.random().toString(36).substring(2, 15);
                      localStorage.setItem("wordcraftDeviceId", deviceId);
                    }

                    // Create a unique ID to help with deduplication
                    const uniqueId = `${nickname}-${score}-${deviceId}-${normalizeDateStr(
                      today
                    )}`;

                    // Get board data for saving - placedTiles and specialSquares for yesterday's best reconstruction
                    // Make sure gameState exists and has the necessary properties
                    const safeGameState = gameState || {};
                    const placedTiles = Array.isArray(safeGameState.placedTiles)
                      ? safeGameState.placedTiles
                      : [];
                    const specialSquares = Array.isArray(
                      safeGameState.specialSquares
                    )
                      ? safeGameState.specialSquares
                      : [];

                    // Get words formed from gameState if available
                    const wordsFormed = [];
                    if (
                      safeGameState.wordData &&
                      Array.isArray(safeGameState.wordData.foundWords)
                    ) {
                      safeGameState.wordData.foundWords.forEach((wordInfo) => {
                        if (wordInfo.word) {
                          wordsFormed.push(wordInfo.word);
                        }
                      });
                    }

                    // Create a clean version of the board data with no undefined values
                    const boardData = {
                      placedTiles: placedTiles.map((tile) => ({
                        row: tile.row || 0,
                        col: tile.col || 0,
                        letter: tile.letter || "",
                        originalIndex: tile.originalIndex || 0,
                        bonus: tile.bonus || null,
                      })),
                      specialSquares: specialSquares.map((square) => ({
                        row: square.row || 0,
                        col: square.col || 0,
                        type: square.type || "",
                        label: square.label || "",
                      })),
                      words: wordsFormed,
                    };

                    // Double check the score validity before saving
                    let validatedScore = parseInt(score);

                    // Only perform minimal validation on the server side

                    // If board data is completely empty but score is non-zero, that's clearly invalid
                    if (
                      boardData.placedTiles.length === 0 &&
                      validatedScore > 0
                    ) {
                      console.error(
                        "Score tampering detected! Empty board with non-zero score"
                      );
                      validatedScore = 0;
                    }

                    // We trust the client-side calculation and validation
                    // This allows for any legitimate score, no matter how high

                    // Format data with consistent field naming and normalized date formats
                    const scoreData = {
                      nickname: nickname,
                      score: validatedScore, // Use validated score
                      date: firebase.firestore.Timestamp.fromDate(now),
                      dateStr: now.toISOString(),
                      day: firebase.firestore.Timestamp.fromDate(today),
                      dayStr: today.toISOString(),
                      uniqueId: uniqueId,
                      deviceId: deviceId,
                      createdAt:
                        firebase.firestore.FieldValue.serverTimestamp(),
                      boardData: {
                        placedTiles: boardData.placedTiles || [],
                        specialSquares: boardData.specialSquares || [],
                        words: wordsFormed,
                      }, // Ensure board data is properly structured
                    };

                    console.log(
                      "Attempting to save score to Firestore:",
                      scoreData
                    );

                    // Check for duplicate scores from the same device and user today
                    const existingScoresQuery = await db
                      .collection("scores")
                      .where("deviceId", "==", deviceId)
                      .where("nickname", "==", nickname)
                      .where("score", "==", parseInt(score))
                      .get();

                    // Don't add if there's already the same score from this device/user today
                    let isDuplicate = false;
                    const todayDateNormalized = normalizeDateStr(today);

                    existingScoresQuery.forEach((doc) => {
                      const data = doc.data();
                      let scoreDate = null;

                      // Try to get a date in a consistent format
                      if (data.day && data.day.toDate) {
                        scoreDate = data.day.toDate();
                      } else if (data.dayStr) {
                        try {
                          scoreDate = new Date(data.dayStr);
                        } catch (e) {}
                      } else if (data.date && data.date.toDate) {
                        scoreDate = data.date.toDate();
                      } else if (data.dateStr) {
                        try {
                          scoreDate = new Date(data.dateStr);
                        } catch (e) {}
                      }

                      if (
                        scoreDate &&
                        normalizeDateStr(scoreDate) === todayDateNormalized
                      ) {
                        console.log(
                          "Duplicate score detected for today, skipping save"
                        );
                        isDuplicate = true;
                      }
                    });

                    if (!isDuplicate) {
                      const docRef = await db
                        .collection("scores")
                        .add(scoreData);
                      console.log("Score saved with ID: ", docRef.id);

                      // Try to sync any pending scores now that we have a connection
                      syncPendingScores();
                    }

                    return true;
                  } catch (error) {
                    console.error("Error saving score: ", error);

                    // Store as pending for later sync
                    const pendingScore = {
                      nickname: nickname,
                      score: score,
                      date: new Date().toISOString(),
                      retryCount: 0,
                      boardData: {
                        placedTiles:
                          boardData && Array.isArray(boardData.placedTiles)
                            ? boardData.placedTiles
                            : [],
                        specialSquares:
                          boardData && Array.isArray(boardData.specialSquares)
                            ? boardData.specialSquares
                            : [],
                      },
                    };

                    pendingScores.push(pendingScore);
                    localStorage.setItem(
                      "wordcraftPendingScores",
                      JSON.stringify(pendingScores)
                    );
                    console.log("Score saved as pending for later sync");

                    return true; // Return true because we stored it as pending
                  }
                },

                getDailyLeaderboard: async function () {
                  try {
                    const today = getNormalizedToday();
                    const todayTimestamp =
                      firebase.firestore.Timestamp.fromDate(today);
                    const tomorrowDate = new Date(today);
                    tomorrowDate.setDate(tomorrowDate.getDate() + 1);
                    const tomorrowTimestamp =
                      firebase.firestore.Timestamp.fromDate(tomorrowDate);

                    console.log(
                      "Fetching daily leaderboard for:",
                      today.toISOString()
                    );

                    // Simplified query that doesn't require a complex index
                    let snapshot;
                    try {
                      // Use a simpler query that doesn't require the complex index
                      // Just filter by day and we'll sort locally
                      snapshot = await db
                        .collection("scores")
                        .where("day", ">=", todayTimestamp)
                        .where("day", "<", tomorrowTimestamp)
                        .limit(1000) // Get more entries for pagination
                        .get({ source: "server" }); // Force server fetch

                      console.log(
                        "Primary query succeeded, filtering today's scores"
                      );
                    } catch (queryError) {
                      console.log(
                        "Day-based query failed, using fallback:",
                        queryError
                      );

                      // Super fallback to simplest possible query (should always work)
                      snapshot = await db
                        .collection("scores")
                        .limit(1000) // Get more entries for pagination
                        .get({ source: "server" }); // Force server fetch
                    }

                    console.log("Firestore query complete, processing results");

                    const scores = [];
                    const todayDateNormalized = normalizeDateStr(today);
                    const seenUsers = new Map(); // Track highest score per user

                    snapshot.forEach((doc) => {
                      const data = doc.data();

                      // Try multiple date fields and formats
                      let isFromToday = false;
                      let scoreDate = null;

                      // Try day Timestamp first
                      if (data.day && data.day.toDate) {
                        scoreDate = data.day.toDate();
                        isFromToday =
                          normalizeDateStr(scoreDate) === todayDateNormalized;
                      }
                      // Try dayStr
                      else if (data.dayStr) {
                        try {
                          scoreDate = new Date(data.dayStr);
                          isFromToday =
                            normalizeDateStr(scoreDate) === todayDateNormalized;
                        } catch (e) {}
                      }
                      // Try date Timestamp
                      else if (data.date && data.date.toDate) {
                        scoreDate = data.date.toDate();
                        isFromToday =
                          normalizeDateStr(scoreDate) === todayDateNormalized;
                      }
                      // Try dateStr
                      else if (data.dateStr) {
                        try {
                          scoreDate = new Date(data.dateStr);
                          isFromToday =
                            normalizeDateStr(scoreDate) === todayDateNormalized;
                        } catch (e) {}
                      }

                      // Only include scores from today that aren't hidden
                      if (isFromToday && !data.hidden) {
                        const scoreEntry = {
                          id: doc.id,
                          nickname: data.nickname,
                          score: data.score,
                          date: scoreDate || new Date(), // Fallback date
                          dateStr:
                            data.dateStr ||
                            (scoreDate
                              ? scoreDate.toISOString()
                              : new Date().toISOString()),
                          uniqueId:
                            data.uniqueId ||
                            `${data.nickname}-${data.score}-${doc.id}`,
                        };

                        // For each user, only keep their highest score
                        const userKey = data.nickname.toLowerCase();
                        if (
                          !seenUsers.has(userKey) ||
                          seenUsers.get(userKey).score < data.score
                        ) {
                          seenUsers.set(userKey, scoreEntry);
                        }
                      }
                    });

                    // Convert Map values to array
                    const uniqueScores = Array.from(seenUsers.values());

                    // Sort by score (highest first)
                    uniqueScores.sort((a, b) => {
                      // First sort by score (descending)
                      if (b.score !== a.score) {
                        return b.score - a.score;
                      }
                      // If scores are equal, sort by date (newest first)
                      return new Date(b.date) - new Date(a.date);
                    });

                    console.log(
                      "Daily leaderboard loaded:",
                      uniqueScores.length,
                      "entries after deduplication"
                    );

                    // If we have no scores, return the fake leaderboard data
                    if (uniqueScores.length === 0) {
                      // Recreate fake leaderboard
                      return leaderboardData.map((item) => ({
                        nickname: item.name,
                        score: item.score,
                        id: "fake_" + Math.random().toString(36).substring(2),
                        date: new Date(),
                        dateStr: new Date().toISOString(),
                        uniqueId: "fake_" + item.name,
                      }));
                    }

                    // Return all scores, not just the top 20
                    return uniqueScores;
                  } catch (error) {
                    console.error("Error getting daily leaderboard: ", error);

                    // Return fake leaderboard data if Firebase fails
                    return leaderboardData.map((item) => ({
                      nickname: item.name,
                      score: item.score,
                      id: "fake_" + Math.random().toString(36).substring(2),
                      date: new Date(),
                      dateStr: new Date().toISOString(),
                      uniqueId: "fake_" + item.name,
                    }));
                  }
                },

                getAllTimeLeaderboard: async function () {
                  try {
                    console.log("Fetching all-time leaderboard");

                    // Get top scores
                    const snapshot = await db
                      .collection("scores")
                      .orderBy("score", "desc")
                      .limit(1000) // Get more entries for pagination
                      .get({ source: "server" }); // Force server fetch

                    console.log("All-time leaderboard query complete");

                    // Keep track of highest score per nickname
                    const highestScorePerUser = new Map();

                    snapshot.forEach((doc) => {
                      const data = doc.data();
                      let scoreDate;

                      // Handle different date formats
                      if (data.date && data.date.toDate) {
                        scoreDate = data.date.toDate();
                      } else if (data.dateStr) {
                        try {
                          scoreDate = new Date(data.dateStr);
                        } catch (e) {
                          scoreDate = new Date();
                        }
                      } else {
                        scoreDate = new Date();
                      }

                      const scoreEntry = {
                        id: doc.id,
                        nickname: data.nickname,
                        score: data.score,
                        date: scoreDate,
                        dateStr: data.dateStr || scoreDate.toISOString(),
                        uniqueId:
                          data.uniqueId ||
                          `${data.nickname}-${data.score}-${doc.id}`,
                      };

                      // For all-time, only keep the highest score per user
                      const userKey = data.nickname.toLowerCase();
                      if (
                        !highestScorePerUser.has(userKey) ||
                        highestScorePerUser.get(userKey).score < data.score
                      ) {
                        highestScorePerUser.set(userKey, scoreEntry);
                      }
                    });

                    // Convert to array and sort
                    const scores = Array.from(highestScorePerUser.values());
                    scores.sort((a, b) => b.score - a.score);

                    console.log(
                      "All-time leaderboard loaded:",
                      scores.length,
                      "entries after deduplication"
                    );

                    // If we have no scores, return the fake leaderboard data
                    if (scores.length === 0) {
                      // Recreate fake leaderboard
                      return leaderboardData.map((item) => ({
                        nickname: item.name,
                        score: item.score,
                        id: "fake_" + Math.random().toString(36).substring(2),
                        date: new Date(),
                        dateStr: new Date().toISOString(),
                        uniqueId: "fake_" + item.name,
                      }));
                    }

                    // Return all scores for pagination
                    return scores;
                  } catch (error) {
                    console.error(
                      "Error getting all-time leaderboard: ",
                      error
                    );

                    // Return fake leaderboard data if Firebase fails
                    return leaderboardData.map((item) => ({
                      nickname: item.name,
                      score: item.score,
                      id: "fake_" + Math.random().toString(36).substring(2),
                      date: new Date(),
                      dateStr: new Date().toISOString(),
                      uniqueId: "fake_" + item.name,
                    }));
                  }
                },

                // Function to sync pending scores
                syncPendingScores: syncPendingScores,
              };

              // Try to sync any pending scores immediately
              syncPendingScores();

              console.log("Firebase initialized successfully");
            })
            .catch((err) => {
              console.error("Failed to enable persistence:", err);
              setupLocalFirebase();

              // Schedule retry with increasing backoff
              if (initRetryCount < MAX_INIT_RETRIES) {
                const retryDelay = Math.pow(2, initRetryCount) * 1000;
                console.log(`Scheduling Firebase retry in ${retryDelay}ms`);

                setTimeout(() => {
                  initRetryCount++;
                  pendingFirebaseInit = false;
                  initFirebase();
                }, retryDelay);
              }
            });
        } catch (error) {
          console.error("Firebase initialization error:", error);
          setupLocalFirebase();
          pendingFirebaseInit = false;
        }
      }

      // Function to sync pending scores to Firebase
      async function syncPendingScores() {
        if (!firebaseReady || pendingScores.length === 0) return;

        console.log(
          `Attempting to sync ${pendingScores.length} pending scores`
        );

        const db = firebase.firestore();
        const successfulSyncs = [];

        for (let i = 0; i < pendingScores.length; i++) {
          const pendingScore = pendingScores[i];

          try {
            const now = new Date();
            const scoreDate = new Date(pendingScore.date);
            const scoreDay = new Date(scoreDate);
            scoreDay.setHours(0, 0, 0, 0);

            // Get device ID
            let deviceId = localStorage.getItem("wordcraftDeviceId");
            if (!deviceId) {
              deviceId =
                "device_" + Math.random().toString(36).substring(2, 15);
              localStorage.setItem("wordcraftDeviceId", deviceId);
            }

            // Create a unique ID
            const uniqueId = `${pendingScore.nickname}-${
              pendingScore.score
            }-${deviceId}-${normalizeDateStr(scoreDay)}`;

            // Get safe board data
            const safeBoardData = pendingScore.boardData || {};
            const placedTiles = Array.isArray(safeBoardData.placedTiles)
              ? safeBoardData.placedTiles
              : [];
            const specialSquares = Array.isArray(safeBoardData.specialSquares)
              ? safeBoardData.specialSquares
              : [];

            // Format data consistently with clean values
            const scoreData = {
              nickname: pendingScore.nickname,
              score: parseInt(pendingScore.score),
              date: firebase.firestore.Timestamp.fromDate(scoreDate),
              dateStr: scoreDate.toISOString(),
              day: firebase.firestore.Timestamp.fromDate(scoreDay),
              dayStr: scoreDay.toISOString(),
              uniqueId: uniqueId,
              deviceId: deviceId,
              createdAt: firebase.firestore.FieldValue.serverTimestamp(),
              syncedAt: firebase.firestore.Timestamp.fromDate(now),
              boardData: {
                placedTiles: placedTiles.map((tile) => ({
                  row: tile.row || 0,
                  col: tile.col || 0,
                  letter: tile.letter || "",
                  originalIndex: tile.originalIndex || 0,
                  bonus: tile.bonus || null,
                })),
                specialSquares: specialSquares.map((square) => ({
                  row: square.row || 0,
                  col: square.col || 0,
                  type: square.type || "",
                  label: square.label || "",
                })),
              },
            };

            // Check for duplicates first
            const existingQuery = await db
              .collection("scores")
              .where("uniqueId", "==", uniqueId)
              .limit(1)
              .get();

            if (existingQuery.empty) {
              await db.collection("scores").add(scoreData);
              console.log(
                `Synced pending score: ${pendingScore.nickname} - ${pendingScore.score}`
              );
              successfulSyncs.push(i);
            } else {
              console.log(
                `Pending score already exists in Firebase, skipping: ${uniqueId}`
              );
              successfulSyncs.push(i);
            }
          } catch (error) {
            console.error(`Failed to sync pending score ${i}:`, error);
            // Increment retry count
            pendingScore.retryCount = (pendingScore.retryCount || 0) + 1;

            // If we've tried too many times, mark for removal
            if (pendingScore.retryCount > 5) {
              console.warn(
                `Abandoning sync for score after ${pendingScore.retryCount} attempts`
              );
              successfulSyncs.push(i);
            }
          }
        }

        // Remove successful syncs (in reverse order to not mess up indices)
        for (let i = successfulSyncs.length - 1; i >= 0; i--) {
          pendingScores.splice(successfulSyncs[i], 1);
        }

        // Update localStorage with remaining pending scores
        localStorage.setItem(
          "wordcraftPendingScores",
          JSON.stringify(pendingScores)
        );
        console.log(
          `Sync complete. ${successfulSyncs.length} scores synced, ${pendingScores.length} pending`
        );
      }

      // Setup local Firebase implementation as fallback
      function setupLocalFirebase() {
        console.warn("Using local leaderboard implementation");

        window.firebaseDB = {
          saveScore: async function (nickname, score) {
            // Add to pending scores for future sync
            const safeGameState = gameState || {};
            const placedTiles = Array.isArray(safeGameState.placedTiles)
              ? safeGameState.placedTiles
              : [];
            const specialSquares = Array.isArray(safeGameState.specialSquares)
              ? safeGameState.specialSquares
              : [];

            const pendingScore = {
              nickname: nickname,
              score: score,
              date: new Date().toISOString(),
              retryCount: 0,
              boardData: {
                placedTiles: placedTiles.map((tile) => ({
                  row: tile.row || 0,
                  col: tile.col || 0,
                  letter: tile.letter || "",
                  originalIndex: tile.originalIndex || 0,
                  bonus: tile.bonus || null,
                })),
                specialSquares: specialSquares.map((square) => ({
                  row: square.row || 0,
                  col: square.col || 0,
                  type: square.type || "",
                  label: square.label || "",
                })),
              },
            };

            pendingScores.push(pendingScore);
            localStorage.setItem(
              "wordcraftPendingScores",
              JSON.stringify(pendingScores)
            );
            console.log("Score saved as pending in offline mode");

            return true;
          },

          getDailyLeaderboard: async function () {
            // Return fake leaderboard data if Firebase fails
            return leaderboardData.map((item) => ({
              nickname: item.name,
              score: item.score,
              id: "fake_" + Math.random().toString(36).substring(2),
              date: new Date(),
              dateStr: new Date().toISOString(),
              uniqueId: "fake_" + item.name,
            }));
          },

          getAllTimeLeaderboard: async function () {
            // Return fake leaderboard data if Firebase fails
            return leaderboardData.map((item) => ({
              nickname: item.name,
              score: item.score,
              id: "fake_" + Math.random().toString(36).substring(2),
              date: new Date(),
              dateStr: new Date().toISOString(),
              uniqueId: "fake_" + item.name,
            }));
          },

          syncPendingScores: syncPendingScores,
        };
      }

      // Initialize with local version while we wait for Firebase
      setupLocalFirebase();

      // Set up periodic sync attempts
      setInterval(() => {
        if (pendingScores.length > 0 && firebaseReady) {
          syncPendingScores();
        }
      }, 30000); // Try every 30 seconds

      // Sync on visibility change (when user returns to tab)
      document.addEventListener("visibilitychange", () => {
        if (
          document.visibilityState === "visible" &&
          pendingScores.length > 0 &&
          firebaseReady
        ) {
          syncPendingScores();
        }

        // Also refresh leaderboard when becoming visible
        if (document.visibilityState === "visible" && firebaseReady) {
          // If leaderboard is visible, refresh it
          if (
            document
              .getElementById("finishGameModal")
              .classList.contains("active")
          ) {
            const activeTab =
              document.querySelector(".tab-btn.active")?.dataset.tab;
            if (activeTab) {
              loadLeaderboard(activeTab, true);
            }
          }
        }
      });

      // Attempt to initialize Firebase
      initFirebase();

      // Listen for online/offline events
      window.addEventListener("online", () => {
        console.log(
          "Device is now online, initializing Firebase and syncing pending scores"
        );
        if (!firebaseReady) {
          pendingFirebaseInit = false; // Reset this flag in case it got stuck
          initFirebase();
        } else if (pendingScores.length > 0) {
          syncPendingScores();
        }

        // Also refresh leaderboard when coming online
        if (
          document
            .getElementById("finishGameModal")
            .classList.contains("active")
        ) {
          const activeTab =
            document.querySelector(".tab-btn.active")?.dataset.tab;
          if (activeTab) {
            loadLeaderboard(activeTab, true);
          }
        }
      });
    </script>

    <script src="script.js"></script>
  </body>
</html>
