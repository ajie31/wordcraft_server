<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>LetterLinks</title>
    <link
      rel="icon"
      type="image/x-icon"
      href="src/icons/fav-icon-letterLink.png"
    />
    <link rel="stylesheet" href="styles.css?v=1.0.2" />
    <!-- IntroJS CSS -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/intro.js@7.2.0/minified/introjs.min.css"
    />
    <!-- here is new style -->
    <link rel="stylesheet" href="keyframes_animation.css" />
    <link rel="stylesheet" href="additional_styles.css" />

    <link
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined"
      rel="stylesheet"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap"
      rel="stylesheet"
    />
    <script
      defer
      data-domain="wordcraft-d6102.web.app"
      src="https://plausible.io/js/script.js"
    ></script>
  </head>
  <body>
    <div id="tilePrefab" class="tile tile-prefab">
      A
      <div class="power-indicator">2x</div>
      <span class="tile-value">0</span>
    </div>
    <button
      id="overlayMenu"
      class="overlay-menu"
      onclick="toggleMenu()"
      style="display: none"
    ></button>
    <div id="mobileNavMenu" class="mobile-nav-menu" style="display: none">
      <div class="anchor-arrow">
        <svg
          width="26"
          height="11"
          viewBox="0 0 26 11"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path d="M13 0L25.9904 10.5H0.00961876L13 0Z" fill="white" />
        </svg>
      </div>
      <div class="nav-menu" id="navMenu">
        <div id="mobileInteractionToggleL" class="mobile-interaction-toggle">
          <span class="input-mode-label">Input mode</span>
          <div class="interaction-btn-wrap">
            <button id="dragModeBtnL" class="interaction-btn">
              Drag and Drop
            </button>
            <button id="tapModeBtnL" class="interaction-btn active">
              Tap Mode
            </button>
          </div>
        </div>
        <div class="nav-menu-rules">
          <span class="input-mode-label">How to Play</span>
          <button
            class="btn"
            id="rulesBtnL"
            data-intro="After submitting, you'll see your final score and can enter your name for the daily leaderboard. Each day brings a new challenge with the same tiles for everyone, so you can compare your skill with others. Have fun!"
            data-step="7"
          >
            <svg
              width="20"
              height="16"
              viewBox="0 0 20 16"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M10 8L2.54 5.02L3 16H1L1.48 4.59L0 4L10 0L20 4L10 8ZM10 3C9.45 3 9 3.22 9 3.5C9 3.78 9.45 4 10 4C10.55 4 11 3.78 11 3.5C11 3.22 10.55 3 10 3ZM10 9L15.57 6.77C16.28 7.71 16.77 8.84 16.93 10.07C16.63 10.03 16.32 10 16 10C13.45 10 11.22 11.37 10 13.41C9.38045 12.371 8.50187 11.5106 7.45018 10.9129C6.39849 10.3152 5.20968 10.0006 4 10C3.68 10 3.37 10.03 3.07 10.07C3.23 8.84 3.72 7.71 4.43 6.77L10 9Z"
                fill="white"
              />
            </svg>

            Show Tutorial
          </button>
        </div>
      </div>
    </div>
    <div id="toast" class="toast"></div>
    <div id="achievementToast" class="achievement-toast"></div>
    <div class="ads-dstp ads-left" id="adsDstpLeft">
      <div class="ads-content-dstp">Ads Here</div>
    </div>
    <div
      class="game-container"
      data-intro="Welcome to LetterLinks! This word-building game gives you a daily challenge to create words on a game board, similar to Scrabble. You'll receive a set of letter tiles and need to arrange them strategically to score points."
      data-step="1"
    >
      <div class="game-header">
        <div class="logo-score-group">
          <div class="display-logo">
            <img src="src/icons/letterLink-logo.svg" alt="wordcraft_logo" />
          </div>
          <div class="score-display">
            <div class="score-container">
              <span class="score-text">Score</span
              ><span class="score-value">0</span>
            </div>
          </div>
        </div>

        <div class="header-button-group">
          <div id="mobileInteractionToggle" class="mobile-interaction-toggle">
            <span class="input-mode-label">Input mode</span>
            <div class="interaction-btn-wrap">
              <button id="dragModeBtn" class="interaction-btn">
                Drag and Drop
              </button>
              <button id="tapModeBtn" class="interaction-btn active">
                Tap Mode
              </button>
            </div>
          </div>
          <button
            class="btn"
            id="rulesBtn"
            data-intro="After submitting, you'll see your final score and can enter your name for the daily leaderboard. Each day brings a new challenge with the same tiles for everyone, so you can compare your skill with others. Have fun!"
            data-step="7"
          >
            <svg
              width="20"
              height="16"
              viewBox="0 0 20 16"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M10 8L2.54 5.02L3 16H1L1.48 4.59L0 4L10 0L20 4L10 8ZM10 3C9.45 3 9 3.22 9 3.5C9 3.78 9.45 4 10 4C10.55 4 11 3.78 11 3.5C11 3.22 10.55 3 10 3ZM10 9L15.57 6.77C16.28 7.71 16.77 8.84 16.93 10.07C16.63 10.03 16.32 10 16 10C13.45 10 11.22 11.37 10 13.41C9.38045 12.371 8.50187 11.5106 7.45018 10.9129C6.39849 10.3152 5.20968 10.0006 4 10C3.68 10 3.37 10.03 3.07 10.07C3.23 8.84 3.72 7.71 4.43 6.77L10 9Z"
                fill="white"
              />
            </svg>

            How to Play
          </button>
          <div class="btn-maximize-display">
            <button onclick="toggleFullscreen()">
              <span class="material-symbols-outlined">crop_free</span>
            </button>
          </div>
          <div class="btn-menu">
            <button onclick="toggleMenu()">
              <span class="material-symbols-outlined">menu</span>
            </button>
          </div>
        </div>
      </div>

      <div class="main-content">
        <div class="game-area">
          <div class="board-container">
            <div
              class="game-board"
              id="gameBoard"
              data-intro="The game board is where you'll place your tiles. To maximize points, use special squares: DL (Double Letter), TL (Triple Letter), DW (Double Word), and TW (Triple Word). Important: The center star square must have a tile placed on it before you can submit your score."
              data-step="3"
            >
              <!-- Board cells will be generated by JavaScript -->
            </div>
            <div
              class="game-board-imagine"
              id="gameBoard-imagine"
              data-step="3"
            >
              <!-- Board cells will be generated by JavaScript -->
            </div>
          </div>
          <div class="tile-area tile-area-desktop" id="tileAreaDesktop">
            <div id="validationErrors" class="validation-errors"></div>

            <!-- Mobile Interaction Mode Toggle -->

            <div class="game-controls-mobile">
              <button
                class="btn btn-primary"
                id="submitBtn"
                data-intro="Once you've arranged your tiles, tap 'Submit Words' to score them. Invalid words will be highlighted in red. Your goal is to score as many points as possible with the available tiles. Try to use all your tiles for maximum points!"
                data-step="6"
              >
                Submit Words
                <svg
                  width="17"
                  height="18"
                  viewBox="0 0 17 18"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    d="M16.235 7.70999L2.66001 0.404991C1.52001 -0.210009 0.20001 0.854991 0.56001 2.09999L2.42001 8.60999C2.49501 8.87999 2.49501 9.14999 2.42001 9.41999L0.56001 15.93C0.20001 17.175 1.52001 18.24 2.66001 17.625L16.235 10.32C16.4666 10.1935 16.6599 10.0069 16.7945 9.77992C16.9291 9.55294 17.0002 9.2939 17.0002 9.02999C17.0002 8.76608 16.9291 8.50704 16.7945 8.28006C16.6599 8.05308 16.4666 7.86653 16.235 7.73999V7.70999Z"
                    fill="white"
                  />
                </svg>
              </button>
              <button
                class="btn"
                id="clearBtn"
                data-intro="Form valid dictionary words by placing tiles adjacent to each other, reading left-to-right or top-to-bottom. All tiles must connect to each other - no isolated groups allowed. Words must be at least two letters long."
                data-step="4"
              >
                <svg
                  width="18"
                  height="22"
                  viewBox="0 0 18 22"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    fill-rule="evenodd"
                    clip-rule="evenodd"
                    d="M11.28 5.80189e-08C11.6998 0.00010886 12.1088 0.132286 12.4493 0.377808C12.7898 0.62333 13.0444 0.96975 13.177 1.368L13.72 3H17C17.2652 3 17.5196 3.10536 17.7071 3.29289C17.8946 3.48043 18 3.73478 18 4C18 4.26522 17.8946 4.51957 17.7071 4.70711C17.5196 4.89464 17.2652 5 17 5L16.997 5.071L16.13 17.214C16.0759 17.9706 15.7372 18.6786 15.182 19.1956C14.6269 19.7125 13.8965 19.9999 13.138 20H4.862C4.10346 19.9999 3.37311 19.7125 2.81797 19.1956C2.26283 18.6786 1.92411 17.9706 1.87 17.214L1.003 5.07L1 5C0.734784 5 0.48043 4.89464 0.292893 4.70711C0.105357 4.51957 0 4.26522 0 4C0 3.73478 0.105357 3.48043 0.292893 3.29289C0.48043 3.10536 0.734784 3 1 3H4.28L4.823 1.368C4.9557 0.969588 5.21043 0.623052 5.5511 0.377515C5.89176 0.131978 6.30107 -0.000101061 6.721 5.80189e-08H11.28ZM6 8C5.75507 8.00003 5.51866 8.08996 5.33563 8.25272C5.15259 8.41547 5.03566 8.63975 5.007 8.883L5 9V15C5.00028 15.2549 5.09788 15.5 5.27285 15.6854C5.44782 15.8707 5.68695 15.9822 5.94139 15.9972C6.19584 16.0121 6.44638 15.9293 6.64183 15.7657C6.83729 15.6021 6.9629 15.3701 6.993 15.117L7 15V9C7 8.73478 6.89464 8.48043 6.70711 8.29289C6.51957 8.10536 6.26522 8 6 8ZM12 8C11.7348 8 11.4804 8.10536 11.2929 8.29289C11.1054 8.48043 11 8.73478 11 9V15C11 15.2652 11.1054 15.5196 11.2929 15.7071C11.4804 15.8946 11.7348 16 12 16C12.2652 16 12.5196 15.8946 12.7071 15.7071C12.8946 15.5196 13 15.2652 13 15V9C13 8.73478 12.8946 8.48043 12.7071 8.29289C12.5196 8.10536 12.2652 8 12 8ZM11.28 2H6.72L6.387 3H11.613L11.28 2Z"
                    fill="#ECA449"
                  />
                </svg>
              </button>
              <button
                class="btn"
                id="shuffleBtn"
                data-intro="Look for special tiles in your rack! Wild cards (with a * symbol) can represent any letter - tap to select which letter you want. Some days, you might also get bonus tiles that double the score of the entire word they're part of."
                data-step="5"
              >
                <svg
                  width="16"
                  height="16"
                  viewBox="0 0 16 16"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    d="M10 16V14H12.6L9.425 10.825L10.85 9.4L14 12.55V10H16V16H10ZM1.4 16L0 14.6L12.6 2H10V0H16V6H14V3.4L1.4 16ZM5.175 6.575L0 1.4L1.4 0L6.575 5.175L5.175 6.575Z"
                    fill="#ECA449"
                  />
                </svg>
              </button>
            </div>
            <div class="page-letter-wrap">
              <div
                class="letter-rack"
                id="letterRack"
                data-intro="At the bottom of the screen, you'll find your letter tiles. Each letter has a point value (shown in the corner). To play, either drag a tile or tap to select it, then tap a board position to place it."
                data-step="2"
              >
                <!-- Tiles will be generated by JavaScript -->
              </div>
            </div>

            <div
              id="postGameMessage"
              class="post-game-message"
              style="display: none"
            >
              <p>
                Today's game completed! Next daily challenge available in
                <span id="postGameCountdown">23:59:59</span>
              </p>
              <button class="btn btn-primary" id="reopenLeaderboardBtn">
                Show Results
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="tile-area tile-area-mobile" id="tileAreaMobile">
      <div id="validationErrors" class="validation-errors"></div>

      <!-- Mobile Interaction Mode Toggle -->

      <div class="game-controls-mobile">
        <button
          class="btn btn-primary"
          id="submitBtn"
          data-intro="Once you've arranged your tiles, tap 'Submit Words' to score them. Invalid words will be highlighted in red. Your goal is to score as many points as possible with the available tiles. Try to use all your tiles for maximum points!"
          data-step="6"
        >
          Submit Words
          <svg
            width="17"
            height="18"
            viewBox="0 0 17 18"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M16.235 7.70999L2.66001 0.404991C1.52001 -0.210009 0.20001 0.854991 0.56001 2.09999L2.42001 8.60999C2.49501 8.87999 2.49501 9.14999 2.42001 9.41999L0.56001 15.93C0.20001 17.175 1.52001 18.24 2.66001 17.625L16.235 10.32C16.4666 10.1935 16.6599 10.0069 16.7945 9.77992C16.9291 9.55294 17.0002 9.2939 17.0002 9.02999C17.0002 8.76608 16.9291 8.50704 16.7945 8.28006C16.6599 8.05308 16.4666 7.86653 16.235 7.73999V7.70999Z"
              fill="white"
            />
          </svg>
        </button>
        <button
          class="btn"
          id="clearBtn"
          data-intro="Form valid dictionary words by placing tiles adjacent to each other, reading left-to-right or top-to-bottom. All tiles must connect to each other - no isolated groups allowed. Words must be at least two letters long."
          data-step="4"
        >
          <svg
            width="18"
            height="22"
            viewBox="0 0 18 22"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M11.28 5.80189e-08C11.6998 0.00010886 12.1088 0.132286 12.4493 0.377808C12.7898 0.62333 13.0444 0.96975 13.177 1.368L13.72 3H17C17.2652 3 17.5196 3.10536 17.7071 3.29289C17.8946 3.48043 18 3.73478 18 4C18 4.26522 17.8946 4.51957 17.7071 4.70711C17.5196 4.89464 17.2652 5 17 5L16.997 5.071L16.13 17.214C16.0759 17.9706 15.7372 18.6786 15.182 19.1956C14.6269 19.7125 13.8965 19.9999 13.138 20H4.862C4.10346 19.9999 3.37311 19.7125 2.81797 19.1956C2.26283 18.6786 1.92411 17.9706 1.87 17.214L1.003 5.07L1 5C0.734784 5 0.48043 4.89464 0.292893 4.70711C0.105357 4.51957 0 4.26522 0 4C0 3.73478 0.105357 3.48043 0.292893 3.29289C0.48043 3.10536 0.734784 3 1 3H4.28L4.823 1.368C4.9557 0.969588 5.21043 0.623052 5.5511 0.377515C5.89176 0.131978 6.30107 -0.000101061 6.721 5.80189e-08H11.28ZM6 8C5.75507 8.00003 5.51866 8.08996 5.33563 8.25272C5.15259 8.41547 5.03566 8.63975 5.007 8.883L5 9V15C5.00028 15.2549 5.09788 15.5 5.27285 15.6854C5.44782 15.8707 5.68695 15.9822 5.94139 15.9972C6.19584 16.0121 6.44638 15.9293 6.64183 15.7657C6.83729 15.6021 6.9629 15.3701 6.993 15.117L7 15V9C7 8.73478 6.89464 8.48043 6.70711 8.29289C6.51957 8.10536 6.26522 8 6 8ZM12 8C11.7348 8 11.4804 8.10536 11.2929 8.29289C11.1054 8.48043 11 8.73478 11 9V15C11 15.2652 11.1054 15.5196 11.2929 15.7071C11.4804 15.8946 11.7348 16 12 16C12.2652 16 12.5196 15.8946 12.7071 15.7071C12.8946 15.5196 13 15.2652 13 15V9C13 8.73478 12.8946 8.48043 12.7071 8.29289C12.5196 8.10536 12.2652 8 12 8ZM11.28 2H6.72L6.387 3H11.613L11.28 2Z"
              fill="#ECA449"
            />
          </svg>
        </button>
        <button
          class="btn"
          id="shuffleBtn"
          data-intro="Look for special tiles in your rack! Wild cards (with a * symbol) can represent any letter - tap to select which letter you want. Some days, you might also get bonus tiles that double the score of the entire word they're part of."
          data-step="5"
        >
          <svg
            width="16"
            height="16"
            viewBox="0 0 16 16"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M10 16V14H12.6L9.425 10.825L10.85 9.4L14 12.55V10H16V16H10ZM1.4 16L0 14.6L12.6 2H10V0H16V6H14V3.4L1.4 16ZM5.175 6.575L0 1.4L1.4 0L6.575 5.175L5.175 6.575Z"
              fill="#ECA449"
            />
          </svg>
        </button>
      </div>
      <div class="page-letter-wrap">
        <div
          class="letter-rack"
          id="letterRack"
          data-intro="At the bottom of the screen, you'll find your letter tiles. Each letter has a point value (shown in the corner). To play, either drag a tile or tap to select it, then tap a board position to place it."
          data-step="2"
        >
          <!-- Tiles will be generated by JavaScript -->
        </div>
      </div>

      <div id="postGameMessage" class="post-game-message" style="display: none">
        <p>
          Today's game completed! Next daily challenge available in
          <span id="postGameCountdown">23:59:59</span>
        </p>
        <button class="btn btn-primary" id="reopenLeaderboardBtn">
          Show Results
        </button>
      </div>
      <div class="ads-wrap">
        <div class="ads-content">
          <h3>ads here</h3>
          <!-- add advertisement here -->
        </div>
      </div>
    </div>
    <div class="ads-dstp ads-right" id="adsDstpRight">
      <div class="ads-content-dstp">Ads Here</div>
    </div>
    <!-- Modals -->
    <div class="modal" id="welcomeModal">
      <div class="modal-content">
        <h2 class="modal-title">Welcome to LetterLinks!</h2>
        <p class="modal-text">
          Create words on the board using your daily letter tiles. Arrange them
          strategically to score the most points!
        </p>
        <ul class="rules-list">
          <li>
            <span class="material-symbols-outlined"> check </span>
            <span
              >Place tiles anywhere, but make sure to use the center star
              square</span
            >
          </li>
          <li>
            <span class="material-symbols-outlined"> check </span>
            <span>Create connected words like in Scrabble</span>
          </li>
          <li>
            <span class="material-symbols-outlined"> check </span>
            <span>Use special squares for bonus points</span>
          </li>
          <li>
            <span class="material-symbols-outlined"> check </span>
            <span>Look for special tiles: Wild cards and bonus tiles!</span>
          </li>
        </ul>
        <p>You can drag tiles or click to select and place them.</p>
        <div class="modal-buttons">
          <button class="btn btn-primary" id="startGameBtn">
            START PLAYING
          </button>
        </div>
      </div>
    </div>

    <!-- Tutorial Modal -->
    <div class="tutorial-modal" id="tutorialModal">
      <div class="tutorial-content">
        <h2 class="tutorial-title">LetterLinks Tutorial</h2>
        <div class="tutorial-steps">
          <!-- Step 1: Introduction -->
          <div class="tutorial-step" data-step="1">
            <div class="tutorial-text">
              Welcome to LetterLinks! This word-building game gives you a daily
              challenge to create words on a game board, similar to Scrabble.
              You'll receive a set of letter tiles and need to arrange them
              strategically to score points.
            </div>
          </div>

          <!-- Step 2: Letter Tiles -->
          <div class="tutorial-step" data-step="2">
            <div class="tutorial-text">
              At the bottom of the screen, you'll find your letter tiles. Each
              letter has a point value (shown in the corner). To play, either
              drag a tile or tap to select it, then tap a board position to
              place it.
            </div>
          </div>

          <!-- Step 3: Game Board -->
          <div class="tutorial-step" data-step="3">
            <div class="tutorial-text">
              The game board is where you'll place your tiles. To maximize
              points, use special squares: DL (Double Letter), TL (Triple
              Letter), DW (Double Word), and TW (Triple Word). Important: The
              center star square must have a tile placed on it before you can
              submit your score.
            </div>
          </div>

          <!-- Step 4: Word Formation -->
          <div class="tutorial-step" data-step="4">
            <div class="tutorial-text">
              Form valid dictionary words by placing tiles adjacent to each
              other, reading left-to-right or top-to-bottom. All tiles must
              connect to each other - no isolated groups allowed. Words must be
              at least two letters long.
            </div>
          </div>

          <!-- Step 5: Special Tiles -->
          <div class="tutorial-step" data-step="5">
            <div class="tutorial-text">
              Look for special tiles in your rack! Wild cards (with a * symbol)
              can represent any letter - tap to select which letter you want.
              Some days, you might also get bonus tiles that double the score of
              the entire word they're part of.
            </div>
          </div>

          <!-- Step 6: Submitting Words -->
          <div class="tutorial-step" data-step="6">
            <div class="tutorial-text">
              Once you've arranged your tiles, tap "Submit Words" to score them.
              Invalid words will be highlighted in red. Your goal is to score as
              many points as possible with the available tiles. Try to use all
              your tiles for maximum points!
            </div>
          </div>

          <!-- Step 7: Leaderboard -->
          <div class="tutorial-step" data-step="7">
            <div class="tutorial-text">
              After submitting, you'll see your final score and can enter your
              name for the daily leaderboard. Each day brings a new challenge
              with the same tiles for everyone, so you can compare your skill
              with others. Have fun!
            </div>
          </div>
        </div>

        <div class="tutorial-progress">
          <!-- Progress dots will be added by JavaScript -->
        </div>

        <div class="tutorial-controls">
          <button class="tutorial-btn tutorial-btn-back" id="tutorialBackBtn">
            Back
          </button>
          <button class="tutorial-btn tutorial-btn-skip" id="tutorialSkipBtn">
            Skip Tutorial
          </button>
          <button class="tutorial-btn tutorial-btn-next" id="tutorialNextBtn">
            Next
          </button>
        </div>
      </div>
    </div>

    <div class="modal" id="rulesModal">
      <div class="modal-wrapper">
        <div class="modal-content">
          <h2 class="modal-title">How to Play</h2>
          <p class="modal-text">
            LetterLinks is a daily word-building challenge.
          </p>
          <ul class="rules-list">
            <li>
              <div><span class="material-symbols-outlined"> check </span></div>
              <div>
                <b>Placing Tiles:</b> Drag or click letters to place them on the
                board
              </div>
            </li>
            <li>
              <div><span class="material-symbols-outlined"> check </span></div>
              <div>
                <b>Center Square:</b> The center star square must have a tile
                before submitting
              </div>
            </li>
            <li>
              <div><span class="material-symbols-outlined"> check </span></div>
              <div>
                <b>Word Formation:</b> Words can be read left-to-right or
                top-to-bottom
              </div>
            </li>
            <li>
              <div><span class="material-symbols-outlined"> check </span></div>
              <div>
                <b>Connecting Words:</b> All tiles must be connected (no
                isolated words)
              </div>
            </li>
            <li>
              <div><span class="material-symbols-outlined"> check </span></div>
              <div>
                <b>Valid Words:</b> Only valid dictionary words will count
                towards your score
              </div>
            </li>
            <li>
              <div><span class="material-symbols-outlined"> check </span></div>
              <div>
                <b>Special Squares:</b>
                <ul>
                  <li>
                    <div class="small-tile small-dl">DL</div>
                    <strong> Double Letter Score</strong>
                  </li>
                  <li>
                    <div class="small-tile small-tl">TL</div>
                    <strong>Triple Letter Score</strong>
                  </li>
                  <li>
                    <div class="small-tile small-dw">DW</div>
                    <strong>Double Word Score</strong>
                  </li>
                  <li>
                    <div class="small-tile small-tw">TW</div>
                    <strong>Triple Word Score</strong>
                  </li>
                </ul>
              </div>
            </li>
            <li>
              <div><span class="material-symbols-outlined"> check </span></div>
              <div>
                <b>Special Tiles:</b>
                <ul>
                  <li>
                    <div class="small-tile small-wild"></div>
                    <span><b>Wild Card</b> - Can represent any letter</span>
                  </li>
                  <li>
                    <div class="small-tile small-powerup"></div>
                    <span>
                      <b>Bonus Tile</b> - Doubles the score of the entire word
                    </span>
                  </li>
                </ul>
              </div>
            </li>
            <li>
              <div><span class="material-symbols-outlined"> check </span></div>
              <div>
                <b>Scoring:</b> Points based on letter values and bonus squares
              </div>
            </li>
            <li>
              <div><span class="material-symbols-outlined"> check </span></div>
              <div>
                <b>Daily Challenge:</b> Everyone gets the same letters each day
              </div>
            </li>
          </ul>
          <div class="modal-buttons">
            <button class="btn btn-primary" id="closeRulesBtn">Got It</button>
            <button class="btn" id="showTutorialFromRulesBtn">
              <svg
                width="21"
                height="20"
                viewBox="0 0 21 20"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M16.9022 11.5836V17.3221V17.3212C16.9061 17.9794 16.6479 18.6122 16.1842 19.0788C15.7206 19.5463 15.0897 19.8095 14.4315 19.8095H9.77563C9.13009 19.8104 8.50996 19.5561 8.04929 19.1033L6.0119 17.1001C5.46318 16.5622 5.37124 15.7102 5.79378 15.0676C6.2173 14.426 7.03596 14.1736 7.74706 14.4651C7.77738 14.4837 7.81553 14.4837 7.84585 14.4651C7.87128 14.4504 7.88595 14.4221 7.88497 14.3927V6.47398C7.88497 5.77072 8.4552 5.20049 9.15748 5.20049C9.86074 5.20049 10.431 5.77072 10.431 6.47398V10.6651C10.7068 10.4 11.0873 10.2729 11.4668 10.3198C11.8472 10.3668 12.1857 10.581 12.3891 10.9047C12.6219 10.535 13.0278 10.31 13.4651 10.31C13.9023 10.31 14.3092 10.535 14.541 10.9047C14.8442 10.4274 15.4262 10.2073 15.969 10.3648C16.5128 10.5213 16.8875 11.0182 16.8884 11.5835L16.9022 11.5836ZM18.4671 3.49757C17.8128 3.49757 17.223 3.89174 16.9726 4.49622C16.7222 5.09973 16.8611 5.79612 17.3237 6.2578C17.7854 6.72046 18.4818 6.85933 19.0853 6.60893C19.6898 6.35854 20.0839 5.76873 20.0839 5.11437C20.0869 4.68204 19.9167 4.26636 19.6105 3.9602C19.3044 3.65404 18.8887 3.4829 18.4564 3.48485L18.4671 3.49757ZM1.61731 10.1203C0.96198 10.1203 0.371198 10.5154 0.12178 11.1209C-0.127636 11.7273 0.0132111 12.4237 0.478793 12.8854C0.943401 13.3471 1.64175 13.482 2.24525 13.2277C2.84876 12.9734 3.24 12.3797 3.23412 11.7244C3.22727 10.8363 2.50542 10.1203 1.61731 10.1203ZM11.9804 4.77309C11.9814 3.78715 11.4698 2.87264 10.6297 2.35717C9.78848 1.84269 8.74093 1.8026 7.86354 2.25252C6.98618 2.70147 6.40617 3.5749 6.3328 4.5579C6.25944 5.5409 6.70351 6.49163 7.50458 7.06586V6.4741C7.50458 5.55468 8.24893 4.80937 9.16833 4.80937C10.0877 4.80937 10.8321 5.5547 10.8321 6.4741V7.04237C11.5529 6.51028 11.9785 5.66902 11.9804 4.77309ZM12.1653 8.46942C13.1933 7.63215 13.8261 6.40463 13.9122 5.08132C13.9992 3.75893 13.5307 2.45893 12.6211 1.49566C11.7105 0.531243 10.4399 -0.00963543 9.11456 0.000129977C7.78922 0.0108892 6.52748 0.572333 5.63257 1.55043C4.73761 2.52852 4.28963 3.83528 4.39722 5.15662C4.50481 6.47802 5.15622 7.69487 6.19791 8.51642C6.23214 8.54282 6.2742 8.5575 6.31724 8.5575C6.68011 8.82549 7.07724 9.04166 7.4988 9.19913V7.53245C6.25564 6.79301 5.658 5.31606 6.03752 3.92025C6.41604 2.5245 7.67976 1.55227 9.12539 1.54345C10.572 1.53367 11.8474 2.49025 12.2436 3.88112C12.6407 5.27199 12.0607 6.75665 10.8273 7.51185V9.18636C11.2616 9.02204 11.6694 8.79414 12.0372 8.5105C12.0841 8.51245 12.1291 8.49778 12.1653 8.46942ZM14.3093 4.9063C14.3093 5.0403 14.3015 5.17039 14.2858 5.29754H16.4582C16.4543 5.232 16.4543 5.16745 16.4582 5.10192C16.4543 5.03638 16.4543 4.97183 16.4582 4.9063H14.3093ZM2.9446 10.2322C3.04046 10.3202 3.12751 10.4161 3.20577 10.5198L5.43583 8.35521C5.34487 8.26131 5.25586 8.16448 5.17467 8.0657L2.9446 10.2322Z"
                  fill="white"
                />
              </svg>
              Interactive Tutorial
            </button>
          </div>
        </div>
      </div>
    </div>

    <div class="modal" id="confirmSubmitModal">
      <div class="modal-content">
        <h2 class="modal-title">Submit Your Words?</h2>
        <p class="modal-text">Are you sure you want to submit your words?</p>
        <p class="modal-text">
          This will end your game for today and record your score on the
          leaderboard.
        </p>

        <div class="modal-buttons">
          <button class="btn" id="cancelSubmitBtn">CANCEL</button>
          <button class="btn btn-primary" id="confirmSubmitBtn">
            SUBMIT WORDS
          </button>
        </div>
      </div>
    </div>

    <!-- New wildcard selection modal -->
    <div class="modal" id="wildcardModal">
      <div class="modal-content">
        <h2 class="modal-title">Select a Letter</h2>
        <p class="modal-text">
          Choose which letter this wildcard should represent:
        </p>
        <div class="letter-grid" id="wildcardLetterGrid">
          <!-- Will be filled dynamically -->
        </div>
        <button class="btn" id="cancelWildcardBtn">Cancel</button>
      </div>
    </div>

    <div class="modal" id="finishGameModal">
      <div class="modal-content">
        <h2 class="modal-title">Game Completed!</h2>
        <div class="finish-game-container">
          <p class="final-message">
            Your final score for today's <b>LetterLinks</b> challenge:
          </p>
          <div class="final-score" id="finalScore">0</div>

          <!-- Nickname Input Form -->
          <div id="nicknameForm" class="nickname-form">
            <p>Enter a nickname to save your score:</p>
            <div class="nickname-input-container">
              <input
                type="text"
                id="nicknameInput"
                maxlength="15"
                placeholder="Your nickname"
                pattern="[A-Za-z0-9 _-]+"
                title="Letters, numbers, spaces, underscores and hyphens only"
              />
              <button id="saveScoreBtn" class="btn btn-primary">
                Save Score
              </button>
            </div>
            <p id="saveScoreMessage" class="save-score-message"></p>
          </div>

          <!-- Leaderboard Tabs -->
          <div class="leaderboard-tabs">
            <button class="tab-btn active" data-tab="daily">
              Today's Scores
            </button>
            <button class="tab-btn" data-tab="alltime">
              All-Time High Scores
            </button>
            <button class="tab-btn" data-tab="yesterdayBest">
              Yesterday's Best
            </button>
            <!-- <button
              class="refresh-btn"
              id="refreshLeaderboardBtn"
              title="Refresh Scores"
            >
              <svg
                width="16"
                height="16"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path d="M23 4v6h-6" />
                <path d="M1 20v-6h6" />
                <path
                  d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"
                />
              </svg>
            </button> -->
          </div>

          <!-- Leaderboard Container -->
          <div id="leaderboardContainer">
            <div class="leaderboard-loading" id="leaderboardLoading">
              Loading scores...
            </div>

            <!-- Standard Leaderboard Table (for daily and all-time) -->
            <table class="leaderboard" id="scoreLeaderboard">
              <thead>
                <tr>
                  <th>Rank</th>
                  <th>Player name</th>
                  <th>Score</th>
                </tr>
              </thead>
              <tbody id="leaderboardBody">
                <!-- Leaderboard entries will be added here -->
              </tbody>
            </table>

            <!-- Yesterday's Best Board View (initially hidden) -->
            <div
              id="yesterdayBestContainer"
              class="yesterday-best-container"
              style="display: none"
            >
              <div class="yesterday-best-header">
                <div class="yesterday-best-info">
                  <div class="yesterday-best-player" id="yesterdayBestPlayer">
                    WordWizard
                  </div>
                  <div class="yesterday-best-score" id="yesterdayBestScore">
                    Score: 285
                  </div>
                </div>
                <div class="yesterday-best-controls">
                  <button id="toggleTilesBtn" class="btn btn-small">
                    Hide Tiles
                  </button>
                </div>
              </div>
              <div class="yesterday-best-board-container">
                <div class="yesterday-best-board" id="yesterdayBestBoard">
                  <!-- Board will be rendered here dynamically -->
                </div>
              </div>
              <div class="yesterday-best-message">
                <p>This is the highest scoring board from yesterday!</p>
              </div>
            </div>
          </div>

          <!-- Statistics Section -->
          <div class="stats-container">
            <h3 class="stats-title">Your Stats</h3>
            <div class="stats-grid" id="playerStats">
              <!-- Will be filled dynamically -->
            </div>
          </div>

          <!-- Achievements Section -->
          <div class="achievements-container">
            <h3 class="achievements-title">Achievements</h3>
            <div class="achievements-grid" id="playerAchievements">
              <!-- Will be filled dynamically -->
            </div>
          </div>

          <div class="countdown">
            <div class="countdown-label">Next daily challenge</div>
            <div class="countdown-time" id="leaderboardCountdown">
              <div class="hour">
                <h2 id="hourCountDown"></h2>
                <span>Hrs</span>
              </div>
              <div class="minute">
                <h2 id="minuteCountDown"></h2>
                <span>Min</span>
              </div>
              <div class="second">
                <h2 id="secondCountDown"></h2>
                <span>Sec</span>
              </div>
            </div>
          </div>

          <div class="share-container">
            <button class="share-button" id="shareScoreBtn">
              <span> SHARE SCORE </span>
              <svg
                width="18"
                height="20"
                viewBox="0 0 18 20"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  fill-rule="evenodd"
                  clip-rule="evenodd"
                  d="M10.803 3.33301C10.803 1.49301 12.303 1.21465e-05 14.151 1.21465e-05C14.5898 -0.00117117 15.0245 0.0841155 15.4303 0.250999C15.8361 0.417882 16.2051 0.663091 16.5161 0.972615C16.8271 1.28214 17.0741 1.64991 17.2429 2.05492C17.4117 2.45992 17.4991 2.89423 17.5 3.33301C17.5 5.17401 16 6.66701 14.151 6.66701C13.7076 6.66734 13.2686 6.57964 12.8593 6.40901C12.4501 6.23838 12.0788 5.98822 11.767 5.67301L7.132 8.82901C7.26085 9.47202 7.19755 10.1387 6.95 10.746L12.032 14.086C12.6307 13.5981 13.3797 13.3321 14.152 13.333C14.5908 13.332 15.0255 13.4174 15.4312 13.5844C15.837 13.7514 16.2059 13.9967 16.5168 14.3063C16.8277 14.6159 17.0746 14.9838 17.2433 15.3888C17.412 15.7939 17.4992 16.2282 17.5 16.667C17.5 18.507 16 20 14.151 20C13.7123 20.0011 13.2777 19.9157 12.872 19.7487C12.4663 19.5818 12.0975 19.3366 11.7866 19.0271C11.4757 18.7175 11.2288 18.3498 11.06 17.9449C10.8913 17.5399 10.8039 17.1057 10.803 16.667C10.8022 16.1996 10.9007 15.7374 11.092 15.311L6.05 12C5.43922 12.5306 4.65706 12.8222 3.848 12.821C3.40922 12.8221 2.97453 12.7366 2.56877 12.5696C2.16301 12.4026 1.79413 12.1573 1.48321 11.8477C1.17229 11.5381 0.925431 11.1702 0.756728 10.7652C0.588024 10.3601 0.500787 9.9258 0.5 9.48701C0.500918 9.04831 0.588253 8.61409 0.757015 8.20915C0.925777 7.80421 1.17266 7.43648 1.48356 7.12697C1.79447 6.81746 2.1633 6.57223 2.569 6.40529C2.97469 6.23834 3.4093 6.15296 3.848 6.15401C4.912 6.15401 5.858 6.64701 6.471 7.41501L10.964 4.35601C10.8568 4.02561 10.8025 3.68036 10.803 3.33301Z"
                  fill="white"
                />
              </svg>
            </button>
          </div>
          <button class="btn btn-primary" id="closeLeaderboardBtn">
            CLOSE
          </button>
        </div>
      </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <!-- IntroJS -->
    <script src="https://cdn.jsdelivr.net/npm/intro.js@7.2.0/minified/intro.min.js"></script>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.19.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.19.1/firebase-firestore-compat.js"></script>

    <script>
      // full screen button
      function toggleFullscreen() {
        const body = document.body; // Target the <body> element
        if (!document.fullscreenElement) {
          if (body.requestFullscreen) {
            body.requestFullscreen();
          } else if (body.webkitRequestFullscreen) {
            // Safari
            body.webkitRequestFullscreen();
          } else if (body.msRequestFullscreen) {
            // IE/Edge
            body.msRequestFullscreen();
          }
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          }
        }
      }

      // menu mobile controller

      function toggleMenu() {
        console.log("menu open");
        const navNemu = document.getElementById("mobileNavMenu");
        const overlay = document.getElementById("overlayMenu");
        if (overlay.style.display === "none") {
          overlay.style.display = "block"; // Hide the overlay
          navNemu.style.display = "flex";
        } else {
          overlay.style.display = "none"; // Show the overlay
          navNemu.style.display = "none";
        }
      }

      // Your web app's Firebase configuration
      const firebaseConfig = {
        apiKey: "AIzaSyCJHbFjv4QqkwdF9uutiCEJtU471lHZWKU",
        authDomain: "wordcraft-d6102.firebaseapp.com",
        projectId: "wordcraft-d6102",
        storageBucket: "wordcraft-d6102.firebasestorage.app",
        messagingSenderId: "972502803354",
        appId: "1:972502803354:web:ee8f30053b5a5f6a2d9023",
        measurementId: "G-HQF2RV9CDQ",
      };

      // Store pending scores that need to be synced to Firebase
      let pendingScores = [];

      // Load any pending scores from localStorage
      try {
        const savedPendingScores = localStorage.getItem(
          "wordcraftPendingScores"
        );
        if (savedPendingScores) {
          pendingScores = JSON.parse(savedPendingScores);
          console.log(`Loaded ${pendingScores.length} pending scores to sync`);
        }
      } catch (e) {
        console.error("Error loading pending scores:", e);
      }

      // Flag to track Firebase state
      let firebaseReady = false;
      let pendingFirebaseInit = false;
      let initRetryCount = 0;
      const MAX_INIT_RETRIES = 3;

      // Helper to normalize date strings
      function normalizeDateStr(dateObj) {
        if (!dateObj) return "";
        return dateObj.toISOString().split("T")[0]; // YYYY-MM-DD format
      }

      // Consistent timestamp handling
      function getNormalizedToday() {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        return today;
      }

      // Initialize Firebase with retry logic
      function initFirebase() {
        if (pendingFirebaseInit) return;

        try {
          pendingFirebaseInit = true;

          // Initialize Firebase
          if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
          }

          // Create a reference to the Firestore database
          const db = firebase.firestore();

          console.log("Trying to initialize Firebase with Firestore");

          // Enable offline persistence with better settings
          db.settings({
            cacheSizeBytes: firebase.firestore.CACHE_SIZE_UNLIMITED,
          });

          db.enablePersistence({ synchronizeTabs: true })
            .then(() => {
              console.log(
                "Firebase offline persistence enabled with multi-tab support"
              );
              firebaseReady = true;

              // Real Firebase implementation
              window.firebaseDB = {
                saveScore: async function (nickname, score) {
                  try {
                    const now = new Date();
                    const today = getNormalizedToday();

                    // Use deviceId to avoid duplication across devices
                    let deviceId = localStorage.getItem("wordcraftDeviceId");
                    if (!deviceId) {
                      deviceId =
                        "device_" + Math.random().toString(36).substring(2, 15);
                      localStorage.setItem("wordcraftDeviceId", deviceId);
                    }

                    // Create a unique ID to help with deduplication
                    const uniqueId = `${nickname}-${score}-${deviceId}-${normalizeDateStr(
                      today
                    )}`;

                    // Get board data for saving - placedTiles and specialSquares for yesterday's best reconstruction
                    // Make sure gameState exists and has the necessary properties
                    const safeGameState = gameState || {};
                    const placedTiles = Array.isArray(safeGameState.placedTiles)
                      ? safeGameState.placedTiles
                      : [];
                    const specialSquares = Array.isArray(
                      safeGameState.specialSquares
                    )
                      ? safeGameState.specialSquares
                      : [];

                    // Get words formed from gameState if available
                    const wordsFormed = [];
                    if (
                      safeGameState.wordData &&
                      Array.isArray(safeGameState.wordData.foundWords)
                    ) {
                      safeGameState.wordData.foundWords.forEach((wordInfo) => {
                        if (wordInfo.word) {
                          wordsFormed.push(wordInfo.word);
                        }
                      });
                    }

                    // Create a clean version of the board data with no undefined values
                    const boardData = {
                      placedTiles: placedTiles.map((tile) => ({
                        row: tile.row || 0,
                        col: tile.col || 0,
                        letter: tile.letter || "",
                        originalIndex: tile.originalIndex || 0,
                        bonus: tile.bonus || null,
                      })),
                      specialSquares: specialSquares.map((square) => ({
                        row: square.row || 0,
                        col: square.col || 0,
                        type: square.type || "",
                        label: square.label || "",
                      })),
                      words: wordsFormed,
                    };

                    // Double check the score validity before saving
                    let validatedScore = parseInt(score);

                    // Only perform minimal validation on the server side

                    // If board data is completely empty but score is non-zero, that's clearly invalid
                    if (
                      boardData.placedTiles.length === 0 &&
                      validatedScore > 0
                    ) {
                      console.error(
                        "Score tampering detected! Empty board with non-zero score"
                      );
                      validatedScore = 0;
                    }

                    // We trust the client-side calculation and validation
                    // This allows for any legitimate score, no matter how high

                    // Format data with consistent field naming and normalized date formats
                    const scoreData = {
                      nickname: nickname,
                      score: validatedScore, // Use validated score
                      date: firebase.firestore.Timestamp.fromDate(now),
                      dateStr: now.toISOString(),
                      day: firebase.firestore.Timestamp.fromDate(today),
                      dayStr: today.toISOString(),
                      uniqueId: uniqueId,
                      deviceId: deviceId,
                      createdAt:
                        firebase.firestore.FieldValue.serverTimestamp(),
                      boardData: {
                        placedTiles: boardData.placedTiles || [],
                        specialSquares: boardData.specialSquares || [],
                        words: wordsFormed,
                      }, // Ensure board data is properly structured
                    };

                    console.log(
                      "Attempting to save score to Firestore:",
                      scoreData
                    );

                    // Check for duplicate scores from the same device and user today
                    const existingScoresQuery = await db
                      .collection("scores")
                      .where("deviceId", "==", deviceId)
                      .where("nickname", "==", nickname)
                      .where("score", "==", parseInt(score))
                      .get();

                    // Don't add if there's already the same score from this device/user today
                    let isDuplicate = false;
                    const todayDateNormalized = normalizeDateStr(today);

                    existingScoresQuery.forEach((doc) => {
                      const data = doc.data();
                      let scoreDate = null;

                      // Try to get a date in a consistent format
                      if (data.day && data.day.toDate) {
                        scoreDate = data.day.toDate();
                      } else if (data.dayStr) {
                        try {
                          scoreDate = new Date(data.dayStr);
                        } catch (e) {}
                      } else if (data.date && data.date.toDate) {
                        scoreDate = data.date.toDate();
                      } else if (data.dateStr) {
                        try {
                          scoreDate = new Date(data.dateStr);
                        } catch (e) {}
                      }

                      if (
                        scoreDate &&
                        normalizeDateStr(scoreDate) === todayDateNormalized
                      ) {
                        console.log(
                          "Duplicate score detected for today, skipping save"
                        );
                        isDuplicate = true;
                      }
                    });

                    if (!isDuplicate) {
                      const docRef = await db
                        .collection("scores")
                        .add(scoreData);
                      console.log("Score saved with ID: ", docRef.id);

                      // Try to sync any pending scores now that we have a connection
                      syncPendingScores();
                    }

                    return true;
                  } catch (error) {
                    console.error("Error saving score: ", error);

                    // Store as pending for later sync
                    const pendingScore = {
                      nickname: nickname,
                      score: score,
                      date: new Date().toISOString(),
                      retryCount: 0,
                      boardData: {
                        placedTiles:
                          boardData && Array.isArray(boardData.placedTiles)
                            ? boardData.placedTiles
                            : [],
                        specialSquares:
                          boardData && Array.isArray(boardData.specialSquares)
                            ? boardData.specialSquares
                            : [],
                      },
                    };

                    pendingScores.push(pendingScore);
                    localStorage.setItem(
                      "wordcraftPendingScores",
                      JSON.stringify(pendingScores)
                    );
                    console.log("Score saved as pending for later sync");

                    return true; // Return true because we stored it as pending
                  }
                },

                getDailyLeaderboard: async function () {
                  try {
                    const today = getNormalizedToday();
                    const todayTimestamp =
                      firebase.firestore.Timestamp.fromDate(today);
                    const tomorrowDate = new Date(today);
                    tomorrowDate.setDate(tomorrowDate.getDate() + 1);
                    const tomorrowTimestamp =
                      firebase.firestore.Timestamp.fromDate(tomorrowDate);

                    console.log(
                      "Fetching daily leaderboard for:",
                      today.toISOString()
                    );

                    // Simplified query that doesn't require a complex index
                    let snapshot;
                    try {
                      // Use a simpler query that doesn't require the complex index
                      // Just filter by day and we'll sort locally
                      snapshot = await db
                        .collection("scores")
                        .where("day", ">=", todayTimestamp)
                        .where("day", "<", tomorrowTimestamp)
                        .limit(1000) // Get more entries for pagination
                        .get({ source: "server" }); // Force server fetch

                      console.log(
                        "Primary query succeeded, filtering today's scores"
                      );
                    } catch (queryError) {
                      console.log(
                        "Day-based query failed, using fallback:",
                        queryError
                      );

                      // Super fallback to simplest possible query (should always work)
                      snapshot = await db
                        .collection("scores")
                        .limit(1000) // Get more entries for pagination
                        .get({ source: "server" }); // Force server fetch
                    }

                    console.log("Firestore query complete, processing results");

                    const scores = [];
                    const todayDateNormalized = normalizeDateStr(today);
                    const seenUsers = new Map(); // Track highest score per user

                    snapshot.forEach((doc) => {
                      const data = doc.data();

                      // Try multiple date fields and formats
                      let isFromToday = false;
                      let scoreDate = null;

                      // Try day Timestamp first
                      if (data.day && data.day.toDate) {
                        scoreDate = data.day.toDate();
                        isFromToday =
                          normalizeDateStr(scoreDate) === todayDateNormalized;
                      }
                      // Try dayStr
                      else if (data.dayStr) {
                        try {
                          scoreDate = new Date(data.dayStr);
                          isFromToday =
                            normalizeDateStr(scoreDate) === todayDateNormalized;
                        } catch (e) {}
                      }
                      // Try date Timestamp
                      else if (data.date && data.date.toDate) {
                        scoreDate = data.date.toDate();
                        isFromToday =
                          normalizeDateStr(scoreDate) === todayDateNormalized;
                      }
                      // Try dateStr
                      else if (data.dateStr) {
                        try {
                          scoreDate = new Date(data.dateStr);
                          isFromToday =
                            normalizeDateStr(scoreDate) === todayDateNormalized;
                        } catch (e) {}
                      }

                      // Only include scores from today that aren't hidden
                      if (isFromToday && !data.hidden) {
                        const scoreEntry = {
                          id: doc.id,
                          nickname: data.nickname,
                          score: data.score,
                          date: scoreDate || new Date(), // Fallback date
                          dateStr:
                            data.dateStr ||
                            (scoreDate
                              ? scoreDate.toISOString()
                              : new Date().toISOString()),
                          uniqueId:
                            data.uniqueId ||
                            `${data.nickname}-${data.score}-${doc.id}`,
                        };

                        // For each user, only keep their highest score
                        const userKey = data.nickname.toLowerCase();
                        if (
                          !seenUsers.has(userKey) ||
                          seenUsers.get(userKey).score < data.score
                        ) {
                          seenUsers.set(userKey, scoreEntry);
                        }
                      }
                    });

                    // Convert Map values to array
                    const uniqueScores = Array.from(seenUsers.values());

                    // Sort by score (highest first)
                    uniqueScores.sort((a, b) => {
                      // First sort by score (descending)
                      if (b.score !== a.score) {
                        return b.score - a.score;
                      }
                      // If scores are equal, sort by date (newest first)
                      return new Date(b.date) - new Date(a.date);
                    });

                    console.log(
                      "Daily leaderboard loaded:",
                      uniqueScores.length,
                      "entries after deduplication"
                    );

                    // If we have no scores, return the fake leaderboard data
                    if (uniqueScores.length === 0) {
                      // Recreate fake leaderboard
                      return leaderboardData.map((item) => ({
                        nickname: item.name,
                        score: item.score,
                        id: "fake_" + Math.random().toString(36).substring(2),
                        date: new Date(),
                        dateStr: new Date().toISOString(),
                        uniqueId: "fake_" + item.name,
                      }));
                    }

                    // Return all scores, not just the top 20
                    return uniqueScores;
                  } catch (error) {
                    console.error("Error getting daily leaderboard: ", error);

                    // Return fake leaderboard data if Firebase fails
                    return leaderboardData.map((item) => ({
                      nickname: item.name,
                      score: item.score,
                      id: "fake_" + Math.random().toString(36).substring(2),
                      date: new Date(),
                      dateStr: new Date().toISOString(),
                      uniqueId: "fake_" + item.name,
                    }));
                  }
                },

                getAllTimeLeaderboard: async function () {
                  try {
                    console.log("Fetching all-time leaderboard");

                    // Get top scores
                    const snapshot = await db
                      .collection("scores")
                      .orderBy("score", "desc")
                      .limit(1000) // Get more entries for pagination
                      .get({ source: "server" }); // Force server fetch

                    console.log("All-time leaderboard query complete");

                    // Keep track of highest score per nickname
                    const highestScorePerUser = new Map();

                    snapshot.forEach((doc) => {
                      const data = doc.data();
                      let scoreDate;

                      // Handle different date formats
                      if (data.date && data.date.toDate) {
                        scoreDate = data.date.toDate();
                      } else if (data.dateStr) {
                        try {
                          scoreDate = new Date(data.dateStr);
                        } catch (e) {
                          scoreDate = new Date();
                        }
                      } else {
                        scoreDate = new Date();
                      }

                      const scoreEntry = {
                        id: doc.id,
                        nickname: data.nickname,
                        score: data.score,
                        date: scoreDate,
                        dateStr: data.dateStr || scoreDate.toISOString(),
                        uniqueId:
                          data.uniqueId ||
                          `${data.nickname}-${data.score}-${doc.id}`,
                      };

                      // For all-time, only keep the highest score per user
                      const userKey = data.nickname.toLowerCase();
                      if (
                        !highestScorePerUser.has(userKey) ||
                        highestScorePerUser.get(userKey).score < data.score
                      ) {
                        highestScorePerUser.set(userKey, scoreEntry);
                      }
                    });

                    // Convert to array and sort
                    const scores = Array.from(highestScorePerUser.values());
                    scores.sort((a, b) => b.score - a.score);

                    console.log(
                      "All-time leaderboard loaded:",
                      scores.length,
                      "entries after deduplication"
                    );

                    // If we have no scores, return the fake leaderboard data
                    if (scores.length === 0) {
                      // Recreate fake leaderboard
                      return leaderboardData.map((item) => ({
                        nickname: item.name,
                        score: item.score,
                        id: "fake_" + Math.random().toString(36).substring(2),
                        date: new Date(),
                        dateStr: new Date().toISOString(),
                        uniqueId: "fake_" + item.name,
                      }));
                    }

                    // Return all scores for pagination
                    return scores;
                  } catch (error) {
                    console.error(
                      "Error getting all-time leaderboard: ",
                      error
                    );

                    // Return fake leaderboard data if Firebase fails
                    return leaderboardData.map((item) => ({
                      nickname: item.name,
                      score: item.score,
                      id: "fake_" + Math.random().toString(36).substring(2),
                      date: new Date(),
                      dateStr: new Date().toISOString(),
                      uniqueId: "fake_" + item.name,
                    }));
                  }
                },

                // Function to sync pending scores
                syncPendingScores: syncPendingScores,
              };

              // Try to sync any pending scores immediately
              syncPendingScores();

              console.log("Firebase initialized successfully");
            })
            .catch((err) => {
              console.error("Failed to enable persistence:", err);
              setupLocalFirebase();

              // Schedule retry with increasing backoff
              if (initRetryCount < MAX_INIT_RETRIES) {
                const retryDelay = Math.pow(2, initRetryCount) * 1000;
                console.log(`Scheduling Firebase retry in ${retryDelay}ms`);

                setTimeout(() => {
                  initRetryCount++;
                  pendingFirebaseInit = false;
                  initFirebase();
                }, retryDelay);
              }
            });
        } catch (error) {
          console.error("Firebase initialization error:", error);
          setupLocalFirebase();
          pendingFirebaseInit = false;
        }
      }

      // Function to sync pending scores to Firebase
      async function syncPendingScores() {
        if (!firebaseReady || pendingScores.length === 0) return;

        console.log(
          `Attempting to sync ${pendingScores.length} pending scores`
        );

        const db = firebase.firestore();
        const successfulSyncs = [];

        for (let i = 0; i < pendingScores.length; i++) {
          const pendingScore = pendingScores[i];

          try {
            const now = new Date();
            const scoreDate = new Date(pendingScore.date);
            const scoreDay = new Date(scoreDate);
            scoreDay.setHours(0, 0, 0, 0);

            // Get device ID
            let deviceId = localStorage.getItem("wordcraftDeviceId");
            if (!deviceId) {
              deviceId =
                "device_" + Math.random().toString(36).substring(2, 15);
              localStorage.setItem("wordcraftDeviceId", deviceId);
            }

            // Create a unique ID
            const uniqueId = `${pendingScore.nickname}-${
              pendingScore.score
            }-${deviceId}-${normalizeDateStr(scoreDay)}`;

            // Get safe board data
            const safeBoardData = pendingScore.boardData || {};
            const placedTiles = Array.isArray(safeBoardData.placedTiles)
              ? safeBoardData.placedTiles
              : [];
            const specialSquares = Array.isArray(safeBoardData.specialSquares)
              ? safeBoardData.specialSquares
              : [];

            // Format data consistently with clean values
            const scoreData = {
              nickname: pendingScore.nickname,
              score: parseInt(pendingScore.score),
              date: firebase.firestore.Timestamp.fromDate(scoreDate),
              dateStr: scoreDate.toISOString(),
              day: firebase.firestore.Timestamp.fromDate(scoreDay),
              dayStr: scoreDay.toISOString(),
              uniqueId: uniqueId,
              deviceId: deviceId,
              createdAt: firebase.firestore.FieldValue.serverTimestamp(),
              syncedAt: firebase.firestore.Timestamp.fromDate(now),
              boardData: {
                placedTiles: placedTiles.map((tile) => ({
                  row: tile.row || 0,
                  col: tile.col || 0,
                  letter: tile.letter || "",
                  originalIndex: tile.originalIndex || 0,
                  bonus: tile.bonus || null,
                })),
                specialSquares: specialSquares.map((square) => ({
                  row: square.row || 0,
                  col: square.col || 0,
                  type: square.type || "",
                  label: square.label || "",
                })),
              },
            };

            // Check for duplicates first
            const existingQuery = await db
              .collection("scores")
              .where("uniqueId", "==", uniqueId)
              .limit(1)
              .get();

            if (existingQuery.empty) {
              await db.collection("scores").add(scoreData);
              console.log(
                `Synced pending score: ${pendingScore.nickname} - ${pendingScore.score}`
              );
              successfulSyncs.push(i);
            } else {
              console.log(
                `Pending score already exists in Firebase, skipping: ${uniqueId}`
              );
              successfulSyncs.push(i);
            }
          } catch (error) {
            console.error(`Failed to sync pending score ${i}:`, error);
            // Increment retry count
            pendingScore.retryCount = (pendingScore.retryCount || 0) + 1;

            // If we've tried too many times, mark for removal
            if (pendingScore.retryCount > 5) {
              console.warn(
                `Abandoning sync for score after ${pendingScore.retryCount} attempts`
              );
              successfulSyncs.push(i);
            }
          }
        }

        // Remove successful syncs (in reverse order to not mess up indices)
        for (let i = successfulSyncs.length - 1; i >= 0; i--) {
          pendingScores.splice(successfulSyncs[i], 1);
        }

        // Update localStorage with remaining pending scores
        localStorage.setItem(
          "wordcraftPendingScores",
          JSON.stringify(pendingScores)
        );
        console.log(
          `Sync complete. ${successfulSyncs.length} scores synced, ${pendingScores.length} pending`
        );
      }

      // Setup local Firebase implementation as fallback
      function setupLocalFirebase() {
        console.warn("Using local leaderboard implementation");

        window.firebaseDB = {
          saveScore: async function (nickname, score) {
            // Add to pending scores for future sync
            const safeGameState = gameState || {};
            const placedTiles = Array.isArray(safeGameState.placedTiles)
              ? safeGameState.placedTiles
              : [];
            const specialSquares = Array.isArray(safeGameState.specialSquares)
              ? safeGameState.specialSquares
              : [];

            const pendingScore = {
              nickname: nickname,
              score: score,
              date: new Date().toISOString(),
              retryCount: 0,
              boardData: {
                placedTiles: placedTiles.map((tile) => ({
                  row: tile.row || 0,
                  col: tile.col || 0,
                  letter: tile.letter || "",
                  originalIndex: tile.originalIndex || 0,
                  bonus: tile.bonus || null,
                })),
                specialSquares: specialSquares.map((square) => ({
                  row: square.row || 0,
                  col: square.col || 0,
                  type: square.type || "",
                  label: square.label || "",
                })),
              },
            };

            pendingScores.push(pendingScore);
            localStorage.setItem(
              "wordcraftPendingScores",
              JSON.stringify(pendingScores)
            );
            console.log("Score saved as pending in offline mode");

            return true;
          },

          getDailyLeaderboard: async function () {
            // Return fake leaderboard data if Firebase fails
            return leaderboardData.map((item) => ({
              nickname: item.name,
              score: item.score,
              id: "fake_" + Math.random().toString(36).substring(2),
              date: new Date(),
              dateStr: new Date().toISOString(),
              uniqueId: "fake_" + item.name,
            }));
          },

          getAllTimeLeaderboard: async function () {
            // Return fake leaderboard data if Firebase fails
            return leaderboardData.map((item) => ({
              nickname: item.name,
              score: item.score,
              id: "fake_" + Math.random().toString(36).substring(2),
              date: new Date(),
              dateStr: new Date().toISOString(),
              uniqueId: "fake_" + item.name,
            }));
          },

          syncPendingScores: syncPendingScores,
        };
      }

      // Initialize with local version while we wait for Firebase
      setupLocalFirebase();

      // Set up periodic sync attempts
      setInterval(() => {
        if (pendingScores.length > 0 && firebaseReady) {
          syncPendingScores();
        }
      }, 30000); // Try every 30 seconds

      // Sync on visibility change (when user returns to tab)
      document.addEventListener("visibilitychange", () => {
        if (
          document.visibilityState === "visible" &&
          pendingScores.length > 0 &&
          firebaseReady
        ) {
          syncPendingScores();
        }

        // Also refresh leaderboard when becoming visible
        if (document.visibilityState === "visible" && firebaseReady) {
          // If leaderboard is visible, refresh it
          if (
            document
              .getElementById("finishGameModal")
              .classList.contains("active")
          ) {
            const activeTab =
              document.querySelector(".tab-btn.active")?.dataset.tab;
            if (activeTab) {
              loadLeaderboard(activeTab, true);
            }
          }
        }
      });

      // Attempt to initialize Firebase
      initFirebase();

      // Listen for online/offline events
      window.addEventListener("online", () => {
        console.log(
          "Device is now online, initializing Firebase and syncing pending scores"
        );
        if (!firebaseReady) {
          pendingFirebaseInit = false; // Reset this flag in case it got stuck
          initFirebase();
        } else if (pendingScores.length > 0) {
          syncPendingScores();
        }

        // Also refresh leaderboard when coming online
        if (
          document
            .getElementById("finishGameModal")
            .classList.contains("active")
        ) {
          const activeTab =
            document.querySelector(".tab-btn.active")?.dataset.tab;
          if (activeTab) {
            loadLeaderboard(activeTab, true);
          }
        }
      });
    </script>

    <script src="script.js"></script>
  </body>
</html>
